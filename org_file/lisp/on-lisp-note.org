#+TITLE: On Lisp 笔记
#+OPTIONS: ^:{}

自底向上的编程方法：一个自底向上的程序由一系列的层写成，每一层都作为更高一层的编程语言。自底向上的编程方法是lisp与生俱来的强项。

* 可扩展语言

** 渐进式设计
常规的做事方式：
1. 仔细计划你打算做的事情
2. 去执行它

但写程序可能就不太适用，程序变数很多，想计划好一切不太现实。lisp允许你遍写程序边做计划。如果要理清自己的思路，试着把它写下来会是最好的方法。边设计边施工有两个重要的后果：程序可以花更少的时间去写，因为当你把计划和实际动手写放在一起的时候，你总可以把精力集中在一个实际的程序上，然后让它日益完善，因为最终的设计必定是进化的成果。只要在把握你程序的命运时坚持一个原则：一旦定位错误的地方，就立即重写它，那么最终的产品将会比事先你花几个星期的时间精心设计的结果更加优雅。

** 自底向上程序设计
自顶向上设计：你说“这个程序的目的是完成这七件事，那么我就把它分成七个主要的子例程。第一个子例程要做四件事，所以它将进一步细分成它自己的四个子例程”，如此这般。

自底向上的设计原则——即通过改变语言来适应程序。有几点好处：
1. 通过让语言担当更多的工作，自底向上设计产生的程序会更加短小轻快。一个更短小的程序就不必划分成那么多的组件了，并且更少的组件意味着程序会更易于阅读和修改。更少的组件也使得组件之间的连接会更少，因而错误发生的机会也会相应减少。一个机械设计师往往努力去减少机器上运动部件的数量，同样有经验的Lisp程序员使用自底向上的设计方法来减小他们程序的规模和复杂度。
2. 自底向上的设计促进了代码重用。当你写两个或更多程序时，许多你为第一个程序写的工具也会对之后的程序开发有帮助。一旦积累下了雄厚的工具基础，写一个新程序所耗费的精力和从最初Lisp环境白手起家相比，前者可能只是后者的几分之一。
3. 自底向上提高了程序的可读性。
4. 由于自底向上的设计驱使你总是去关注代码中的模式，这种工作方式有助于理清设计程序时的思路。如果一个程序中两个关系很远的组件在形式上很相似，你就会因此注意到这种相似性，然后也许会以更简单的方式重新设计程序。

** 可扩展软件
如果我们不能给用户一个现成的软件，让它能完成用户想要的每个功能，那么我们也可以交付一个可扩展的软件。

** 扩展Lisp
有两种方式可以为Lisp增加新的操作符：函数和宏。

* 函数
除了少数称为特殊形式（special form）的操作符之外，Lisp的核心就是一个函数的集合。在Lisp里，+和你自己定义的函数一样，也是个函数。

** 作为数据的函数
Lisp中函数作为一种数据类型，像整数那样：在运行期创建一个新函数，把函数保存在变量和结构体里面，作为参数传递，作为函数的返回值。

** 定义函数
defun并不只是过程定义，它们还是Lisp调用。同时，函数本身也是对象。defun实际所做的就是构造这样的对象，然后把它保存在第一个参数名下。Common Lisp的函数是第一类（first-class）对象，它和整数和字符串这些更熟悉的对象享有完全相同的权利。

在Common Lisp里，我们可以同时拥有名为double的函数和变量。当名字出现在函数调用的首位，或者前置#'的时候，他被认为是函数。其他场合下它被当成变量名。因此我们说Common Lisp拥有独立的函数和变量名字空间（name-space）。Common Lisp提供了两个函数用于将符号映射到它所代表的函数或者变量：symbol-function和symbol-value。深入分析的话，defun实际上是把它第一个参数的symbol-function设置成了用它其余部分构造的函数：
#+BEGIN_SRC lisp -n
  (defun double (x) (* x 2))
  ;; 两个表达式完成的功能基本相同
  (setf (symbol-function 'double)
        #' (lambda (x) (* x 2)))
#+END_SRC

** 函数型参数
无论是使用内置的工具，比如sort，还是编写你的实用工具，基本原则是一样的：与其把功能写死，不如传进去一个函数参数。

** 作为属性的函数
函数作为Lisp对象这一事实也创造了条件，让我们能够编写出那种可以随时扩展以满足新需求的程序。假设我们需要写一个以动物种类作为参数并产生相应行为的函数。在大多数语言中，会使用case语句达到这个目的，Lisp里也可以用同样的办法：
#+BEGIN_SRC lisp -n
  (defun behave (animal)
    (case animal
      (dog (wag-tail)
           (bark))
      (rat (scurry)
           (squeak))
      (cat (rub-legs)
           (scratch-carpet))))
#+END_SRC
如果要增加一种新动物该怎么办呢？如果计划增加新的动物，那么把behave定义成下面的样子可能会更好一些：
#+BEGIN_SRC lisp -n
  (defun behave (animal)
    (funcall (get animal ’behavior)))
#+END_SRC
同时把每种个体动物的行为以单独的函数形式保存，例如，存放在以它们名字命名的属性列表里：
#+BEGIN_SRC lisp -n
  (setf (get ’dog ’behavior)
        #’(lambda ()
             (wag-tail)
             (bark)))
#+END_SRC
用这种方式处理的话，要增加一种新动物，所有你需要做的事情就是定义一个新的属性。一个函数都不用写。

不过这种方式会慢一些，如果速度很关键，我们可以把属性表换成结构体，而且特别要用编译过的函数代替解释性的函数。（到2.9节看怎样做到这些）使用了结构体和编译函数，其速度可以达到甚至超过那些使用case语句的实现。当然面向对象中的方法和继承也可以很好的实现上述扩展，如果我们要的可扩展性不是很依赖继承，那么纯Lisp可能就已经足够应付了。

** 作用域
Common Lisp是词法作用域(lexically scope)的Lisp
#+BEGIN_SRC lisp -n
  (let ((y 7))
    (defun scope-test (x)
      (list x y)))
  
  (let ((y 5))
    (scope-test 3))
  ;; 动态作用域 (3 5)
  ;; 词法作用域 (3 7)
#+END_SRC
** 闭包
由于Common Lisp是词法作用域的，所以如果定义含有自由变量的函数（如上节中y），系统就必须在函数定义时保存那些变量的绑定。这种函数和一组变量绑定的组合称为闭包。
** 局部函数
#+BEGIN_SRC lisp -n
  (defun test-labels (x)
    (labels ((name (parameters)
               (body)))
      (name parameters)))
#+END_SRC
** 尾递归
如果这个函数调用自己之后不做其他工作，这种调用就称为尾递归（tail-recursive）。
许多cl编译器都可以把尾递归转化成循环，这样就不必担心函数调用在运行期产生的系统开销。
如果一个函数不是尾递归的话，常常可以把一个使用累积器（accumulator）的局部函数嵌入其中，用这种方法把它转换成尾递归形式。
#+BEGIN_SRC lisp -n
  (defun our-length (lst)
    (labels ((rec (lst acc)
               (if (null lst)
                   acc
                   (rec (cdr lst) (1+ acc)))))
      (rec lst 0)))
#+END_SRC
许多cl编译器都能做尾递归优化，但这并不是所有编译器的默认行为。所以在编写尾递归函数时，应该把以下这句写在文件的最前面，确保编译器不会辜负你的苦心，进行期望的优化。
: (proclaim '(optimize speed))
如果提供尾递归和类型声明，现有的cl编译器就能生成运行速度能与c程序相媲美，甚至超过它的代码。下面代码从1累加到n：
#+BEGIN_SRC lisp -n
  (defun triangle (n)
    (labels ((tri (c n)
               (declare (type fixnum n c))
               (if (zerop n)
                   c
                   (tri (the fixnum (+ n c))
                        (the fixnum (- n 1))))))
      (tri 0 n)))
#+END_SRC
这就是快速cl代码的典范，一开始就用这样写程序可能会觉得不太自然。更好的办法是先用自己最习惯的方式编写函数，然后在必要时把它转化成尾递归的等价形式。
** 编译
这节现在有很多不懂的，之后要返回来再看
** 来自列表的函数

* 函数式编程
** 函数式设计
函数式编程意味着利用返回值而不是副作用来写程序。副作用包括破坏性修改对象以及变量赋值。如果副作用很少并且局部化，程序就会容易阅读，测试和调试。

