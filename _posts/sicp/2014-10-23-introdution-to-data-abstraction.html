---
layout: post
title: 2.1 数据抽象
category: sicp
description: sicp 2.1节 笔记
---

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>2.1 数据抽象</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="2.1 数据抽象"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-10-23T08:11+0800"/>
<meta name="author" content="leon"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">2.1 数据抽象</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 例子：有理数的算术运算</a>
<ul>
<li><a href="#sec-1-1">1.1 习题</a></li>
</ul>
</li>
<li><a href="#sec-2">2 抽象屏障</a>
<ul>
<li><a href="#sec-2-1">2.1 习题</a></li>
</ul>
</li>
<li><a href="#sec-3">3 数据意味着什么</a>
<ul>
<li><a href="#sec-3-1">3.1 习题</a></li>
</ul>
</li>
<li><a href="#sec-4">4 扩展练习：区间算术</a>
<ul>
<li><a href="#sec-4-1">4.1 习题</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 例子：有理数的算术运算</h2>
<div class="outline-text-2" id="text-1">

<p>假定我们做有理数上的算术，加减乘除和比较两个有理数是否相等，等等。
</p>
<p>
假定我们已经有了一种从分子和分母构造有理数的方法。并进一步假定，如果有了一个有理数，我们能够取得它的分子和分母
</p><ul>
<li>(make-rat &lt;n&gt; &lt;d&gt;) returns the rational number whose numerator is the integer &lt;n&gt; and whose denominator is the integer &lt;d&gt;.
</li>
<li>(numer &lt;x&gt;) returns the numerator of the rational number &lt;x&gt;.
</li>
<li>(denom &lt;x&gt;) returns the denominator of the rational number &lt;x&gt;.
</li>
</ul>

<p>那么就可以根据下面的关系做有理数的加减乘除和相等的判断了：
</p>
<p>
<img src="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-1.gif"  alt="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-1.gif" />
</p>
<p>
<img src="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-2.gif"  alt="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-2.gif" />
</p>
<p>
<img src="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-3.gif"  alt="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-3.gif" />
</p>
<p>
<img src="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-4.gif"  alt="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-4.gif" />
</p>
<p>
<img src="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-5.gif"  alt="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-5.gif" />
</p>



<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-rat</span> (x y)
<span class="linenr"> 2:  </span>  (make-rat (+ (* (numer x) (denom y))
<span class="linenr"> 3:  </span>               (* (numer y) (denom x)))
<span class="linenr"> 4:  </span>            (* (denom x) (denom y))))
<span class="linenr"> 5:  </span>
<span class="linenr"> 6:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">sub-rat</span> (x y)
<span class="linenr"> 7:  </span>  (make-rat (- (* (numer x) (denom y))
<span class="linenr"> 8:  </span>               (* (numer y) (denom x)))
<span class="linenr"> 9:  </span>            (* (denom x) (denom y))))
<span class="linenr">10:  </span>
<span class="linenr">11:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">mul-rat</span> (x y)
<span class="linenr">12:  </span>  (make-rat (* (numer x) (numer y))
<span class="linenr">13:  </span>            (* (denom x) (denom y))))
<span class="linenr">14:  </span>
<span class="linenr">15:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">div-rat</span> (x y)
<span class="linenr">16:  </span>  (make-rat (* (numer x) (denom y))
<span class="linenr">17:  </span>            (* (denom x) (numer y))))
<span class="linenr">18:  </span>
<span class="linenr">19:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">equal-rat-p</span> (x y)
<span class="linenr">20:  </span>  (= (* (numer x) (denom y))
<span class="linenr">21:  </span>     (* (numer y) (denom x))))
</pre>

<p>
我们可以采用 cons 来表示有理数，car表示分子，cdr表示分母
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-rat</span> (n d)
<span class="linenr"> 2:  </span>  (cons n d))
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">numer</span> (x)
<span class="linenr"> 5:  </span>  (car x))
<span class="linenr"> 6:  </span>
<span class="linenr"> 7:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">denom</span> (x)
<span class="linenr"> 8:  </span>  (cdr x))
<span class="linenr"> 9:  </span>
<span class="linenr">10:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-rat</span> (x)
<span class="linenr">11:  </span>  (fresh-line)
<span class="linenr">12:  </span>  (princ (numer x))
<span class="linenr">13:  </span>  (princ <span style="color: #8b2252;">"/"</span>)
<span class="linenr">14:  </span>  (princ (denom x)))
<span class="linenr">15:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">(format t "~&amp;~A/~A" (numer x) (denom x))</span>
</pre>

<p>
测试一下：
</p><pre class="example">
(print-rat (add-rat *one-third* *one-third*)) ==&gt; 6/9
</pre>

<p>发现没有约分到最简形式，通过用gcd函数（找到最大公约数）修改make-rat
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-rat</span> (n d)
<span class="linenr">2:  </span>  (<span style="color: #a020f0;">let</span> ((g (gcd n d)))
<span class="linenr">3:  </span>    (cons (/ n g) (/ d g))))
</pre>

<p>
测试：
</p><pre class="example">
(print-rat (add-rat *one-third* *one-third*)) ==&gt; 2/3
</pre>



</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 习题</h3>
<div class="outline-text-3" id="text-1-1">

<p>Exercise 2.1.  Define a better version of make-rat that handles both positive and negative arguments. Make-rat should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.
</p>
<p class="verse">
n/d -&gt; n/d<br/>
-n/-d -&gt; n/d<br/>
-n/d -&gt; -n/d<br/>
n/-d -&gt; -n/d<br/>
</p>


<p>
看出，如果d为负数，n与d都取反，d为正数则不变
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-rat</span> (n d)
<span class="linenr">2:  </span>  (<span style="color: #a020f0;">labels</span> ((make-rat-inner (n d)
<span class="linenr">3:  </span>             (<span style="color: #a020f0;">let</span> ((g (gcd n d)))
<span class="linenr">4:  </span>               (cons (/ n g) (/ d g)))))
<span class="linenr">5:  </span>    (<span style="color: #a020f0;">if</span> (minusp d)
<span class="linenr">6:  </span>        (make-rat-inner (- n) (- d))
<span class="linenr">7:  </span>        (make-rat-inner n d))))
</pre>


</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 抽象屏障</h2>
<div class="outline-text-2" id="text-2">

<p>数据抽象的基本思想就是为每一类数据对象标识出一组操作，使得对这类数据对象的所有操作都可以基于它们表述，而且在操作这些数据对象时也只使用它们。
</p>
<p>
<img src="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-6.gif"  alt="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-6.gif" />
</p>
<p>
这种方法使程序很容易维护和修改。
</p>
<p>
任意一种比较复杂的数据结构，都可以以多种不同方式用语言所提供的基本数据结构表示。当然，表示方式的选择会对操作它的程序产生影响，如果后来表示方式改变了，所有受影响的程序也都需要随之改变。对于大型程序而言，这种工作将非常耗时，而且代价昂贵，除非在设计时就已经将依赖于表示的成分限制到很少的一些程序模块上。
</p>
<p>
例如，将有理数约化到最简形式的工作，也完全可以不在构造的时候做，而是在每次访问有理数中有关部分时去做：
</p>


<pre class="src src-scheme"><span class="linenr">1:  </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">make-rat</span> n d)
<span class="linenr">2:  </span>  (cons n d))
<span class="linenr">3:  </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">numer</span> x)
<span class="linenr">4:  </span>  (<span style="color: #a020f0;">let</span> ((g (gcd (car x) (cdr x))))
<span class="linenr">5:  </span>    (/ (car x) g)))
<span class="linenr">6:  </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">denom</span> x)
<span class="linenr">7:  </span>  (<span style="color: #a020f0;">let</span> ((g (gcd (car x) (cdr x))))
<span class="linenr">8:  </span>    (/ (cdr x) g)))
</pre>

<p>
这一实现与前面实现不同之处在于何时计算gcd。如果我们需要多次访问同一个有理数的分子和分母，那么最好是在构造有理数的时候计算gcd。如果情况不是这样，那么把对gcd的计算推迟到访问时也许更好一些。
*在这里，在任何情况下，当我们从一种表示方式转到另一种表示方式时，过程add-rat、sub-rat等都完全不必修改。*
</p>
<p>
这样把对于具体表示方式的依赖性限制到少数几个页面过程，不但对修改程序有帮助，同时也有助于程序的设计，因为这种做法将使我们能保留考虑不同实现方式的灵活性。假定现在我们正在设计有理数程序包，而且还无法决定究竟是在创建时执行gcd，还是应该将它推迟到选择的时候。数据抽象方法使我们能推迟决策的时间，而又不会阻碍系统其他部分的工作进展。
</p>

</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 习题</h3>
<div class="outline-text-3" id="text-2-1">

<p>Exercise 2.2.  Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Define a constructor make-segment and selectors start-segment and end-segment that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the x coordinate and the y coordinate. Accordingly, specify a constructor make-point and selectors x-point and y-point that define this representation. Finally, using your selectors and constructors, define a procedure midpoint-segment that takes a line segment as argument and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints). To try your procedures, you'll need a way to print points:
</p>


<pre class="src src-scheme"><span class="linenr">1:  </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">print-point</span> p)
<span class="linenr">2:  </span>  (newline)
<span class="linenr">3:  </span>  (display <span style="color: #8b2252;">"("</span>)
<span class="linenr">4:  </span>  (display (x-point p))
<span class="linenr">5:  </span>  (display <span style="color: #8b2252;">","</span>)
<span class="linenr">6:  </span>  (display (y-point p))
<span class="linenr">7:  </span>  (display <span style="color: #8b2252;">")"</span>))
</pre>



<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">midpoint-segment</span> (segment)
<span class="linenr"> 2:  </span>  (<span style="color: #a020f0;">let</span> ((start-p (start-segment segment))
<span class="linenr"> 3:  </span>        (end-p (end-segment segment)))
<span class="linenr"> 4:  </span>    (make-point (average (x-point start-p)
<span class="linenr"> 5:  </span>                         (x-point end-p))
<span class="linenr"> 6:  </span>                (average (y-point start-p)
<span class="linenr"> 7:  </span>                         (y-point end-p)))))
<span class="linenr"> 8:  </span>
<span class="linenr"> 9:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">average</span> (x y)
<span class="linenr">10:  </span>  (/ (+ x y) 2.0))
<span class="linenr">11:  </span>
<span class="linenr">12:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-segment</span> (start-p end-p)
<span class="linenr">13:  </span>  (cons start-p end-p))
<span class="linenr">14:  </span>
<span class="linenr">15:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">start-segment</span> (segment)
<span class="linenr">16:  </span>  (car segment))
<span class="linenr">17:  </span>
<span class="linenr">18:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">end-segment</span> (segment)
<span class="linenr">19:  </span>  (cdr segment))
<span class="linenr">20:  </span>
<span class="linenr">21:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-point</span> (p)
<span class="linenr">22:  </span>  (format t <span style="color: #8b2252;">"~&amp;(~A,~A)"</span> (x-point p) (y-point p)))
<span class="linenr">23:  </span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(fresh-line)</span>
<span class="linenr">24:  </span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(princ "(")</span>
<span class="linenr">25:  </span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(princ (x-point p))</span>
<span class="linenr">26:  </span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(princ ",")</span>
<span class="linenr">27:  </span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(princ (y-point p))</span>
<span class="linenr">28:  </span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(princ ")"))</span>
<span class="linenr">29:  </span>
<span class="linenr">30:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-point</span> (x y)
<span class="linenr">31:  </span>  (cons x y))
<span class="linenr">32:  </span>
<span class="linenr">33:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">x-point</span> (p)
<span class="linenr">34:  </span>  (car p))
<span class="linenr">35:  </span>
<span class="linenr">36:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">y-point</span> (p)
<span class="linenr">37:  </span>  (cdr p))
</pre>


<p>
Exercise 2.3.  Implement a representation for rectangles in a plane. (Hint: You may want to make use of exercise 2.2.) In terms of your constructors and selectors, create procedures that compute the perimeter and the area of a given rectangle. Now implement a different representation for rectangles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area procedures will work using either representation?
</p>
<p>
我用height(线段)和width(线段)来表示rectangle，所以我的程序层次为：
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">programs thats use rect</th></tr>
</thead>
<tbody>
<tr><td class="left">perimeter-rect area-rect</td></tr>
<tr><td class="left">make-rect width-rect height-rect</td></tr>
<tr><td class="left">cons car cdr</td></tr>
</tbody>
</table>


<p>
第一种表示方式：rect用线段宽和线段高来构造
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">perimeter-rect</span> (rect)
<span class="linenr"> 2:  </span>  (* 2 (+ (length-width-rect rect)
<span class="linenr"> 3:  </span>          (length-height-rect rect))))
<span class="linenr"> 4:  </span>
<span class="linenr"> 5:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">area-rect</span> (rect)
<span class="linenr"> 6:  </span>  (* (length-width-rect rect))
<span class="linenr"> 7:  </span>     (length-height-rect rect))))
<span class="linenr"> 8:  </span>
<span class="linenr"> 9:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">length-width-rect</span> (rect)
<span class="linenr">10:  </span>  (length-segment (width-rect rect)))
<span class="linenr">11:  </span>
<span class="linenr">12:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">length-height-rect</span> (rect)
<span class="linenr">13:  </span>  (length-segment (height-rect rect)))
<span class="linenr">14:  </span>
<span class="linenr">15:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#31532;&#19968;&#31181;&#34920;&#31034;&#27861;&#65306;&#29992;segment&#23485;&#21644;segment&#39640;&#26469;&#26500;&#36896;</span>
<span class="linenr">16:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-rect</span> (width height)
<span class="linenr">17:  </span>  (cons width height))
<span class="linenr">18:  </span>
<span class="linenr">19:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">width-rect</span> (rect)
<span class="linenr">20:  </span>  (car rect))
<span class="linenr">21:  </span>
<span class="linenr">22:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">height-rect</span> (rect)
<span class="linenr">23:  </span>  (cdr rect))
<span class="linenr">24:  </span>
<span class="linenr">25:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">length-segment</span> (segment)
<span class="linenr">26:  </span>  (<span style="color: #a020f0;">let</span> ((start-p (start-segment segment))
<span class="linenr">27:  </span>        (end-p (end-segment segment)))
<span class="linenr">28:  </span>    (expt (+ (expt (- (x-point start-p)
<span class="linenr">29:  </span>                      (x-point end-p))
<span class="linenr">30:  </span>                   2)
<span class="linenr">31:  </span>             (expt (- (y-point start-p)
<span class="linenr">32:  </span>                      (y-point end-p))
<span class="linenr">33:  </span>                   2))
<span class="linenr">34:  </span>          .5)))  
</pre>

<p>
第二种表示方式：用相邻的三个点来构造。只需要改make-rect
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#31532;&#20108;&#31181;&#34920;&#31034;&#27861;&#65306;&#29992;&#30456;&#37051;&#30340;&#19977;&#28857;&#26469;&#26500;&#36896;</span>
<span class="linenr">2:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-rect</span> (p1 p2 p3)
<span class="linenr">3:  </span>  (<span style="color: #a020f0;">let</span> ((seg12 (make-segment p1 p2))
<span class="linenr">4:  </span>        (seg23 (make-segment p2 p3)))
<span class="linenr">5:  </span>    (<span style="color: #a020f0;">if</span> (&gt; (length-segment seg12)
<span class="linenr">6:  </span>           (length-segment seg23))
<span class="linenr">7:  </span>        (cons seg23 seg12)
<span class="linenr">8:  </span>        (cons seg12 seg23))))
</pre>

<p>
第三种表示方式：把比较线段长度放在别处
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#31532;&#19977;&#31181;&#34920;&#31034;&#27861;</span>
<span class="linenr"> 2:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-rect</span> (p1 p2 p3)
<span class="linenr"> 3:  </span>  (cons (make-segment p1 p2)
<span class="linenr"> 4:  </span>        (make-segment p2 p3)))
<span class="linenr"> 5:  </span>
<span class="linenr"> 6:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">width-rect</span> (rect)
<span class="linenr"> 7:  </span>  (<span style="color: #a020f0;">if</span> (&gt; (length-segment (car rect))
<span class="linenr"> 8:  </span>         (length-segment (cdr rect)))
<span class="linenr"> 9:  </span>      (cdr rect)
<span class="linenr">10:  </span>      (car rect)))
<span class="linenr">11:  </span>
<span class="linenr">12:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">height-rect</span> (rect)
<span class="linenr">13:  </span>  (<span style="color: #a020f0;">if</span> (&gt; (length-segment (car rect))
<span class="linenr">14:  </span>         (length-segment (cdr rect)))
<span class="linenr">15:  </span>      (car rect)
<span class="linenr">16:  </span>      (cdr rect)))
</pre>

<p>
如果只是计算周长和面积并不用比较出宽和高的区别。
</p>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 数据意味着什么</h2>
<div class="outline-text-2" id="text-3">

<p>一般而言，我们总可以将数据定义为一组适当的选择函数和构造函数，以及为使这一套过程成为一套合法表示，它们就必须满足的一组特定条件。
如make-rat,number,denom必须满足下面条件，对于任意整数n和任意非零整数d，如果x是(make-rat n d)，那么：
</p>
<p>
<img src="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-7.gif"  alt="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-7.gif" />
</p>
<p>
就像Java中的bean对象，构造函数和get方法，对象就是数据的封装。
</p>
<p>
对于序对（pair）来说，我们从来没有说序对究竟是什么，只说语言为序对的操作提供了三个过程cons，car，cdr。
这些操作满足的条件是：对于任何对象x和y，如果z是(cons x y)，那么(car z)就是x，(cdr z)就是y
</p>
<p>
我们完全可以不用任何数据结构，只使用过程就可以实现序对：
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">our-cons</span> (x y)
<span class="linenr"> 2:  </span>  (<span style="color: #a020f0;">labels</span> ((dispatch (m)
<span class="linenr"> 3:  </span>             (<span style="color: #a020f0;">cond</span> ((= m 0) x)
<span class="linenr"> 4:  </span>                   ((= m 1) y)
<span class="linenr"> 5:  </span>                   (t (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Argument not 0 or 1"</span> m)))))
<span class="linenr"> 6:  </span>    #'dispatch))
<span class="linenr"> 7:  </span>
<span class="linenr"> 8:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">our-car</span> (z)
<span class="linenr"> 9:  </span>  (funcall z 0))
<span class="linenr">10:  </span>
<span class="linenr">11:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">our-cdr</span> (z)
<span class="linenr">12:  </span>  (funcall z 1))
</pre>

<p>
如果只使用cons,car,cdr访问序对，我们无法区分这一实现和“真正的”数据结构。
</p>
<p>
数据的过程性表示将在我们的程序设计宝库中扮演一种核心角色。
</p>
<p>
Exercise 2.4.  Here is an alternative procedural representation of pairs. For this representation, verify that (car (cons x y)) yields x for any objects x and y.
</p>


<pre class="src src-scheme"><span class="linenr">1:  </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">cons</span> x y)
<span class="linenr">2:  </span>  (<span style="color: #a020f0;">lambda</span> (m) (m x y)))
<span class="linenr">3:  </span>
<span class="linenr">4:  </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">car</span> z)
<span class="linenr">5:  </span>  (z (<span style="color: #a020f0;">lambda</span> (p q) p)))
</pre>

<p>
What is the corresponding definition of cdr? (Hint: To verify that this works, make use of the substitution model of section 1.1.5.)
</p>
<p>
替换模型
</p>


<pre class="example"><span class="linenr">1:  </span>(car (cons x y))
<span class="linenr">2:  </span>(car (lambda (m) (m x y)))
<span class="linenr">3:  </span>((lambda (m) (m x y)) (lambda (p q) p))
<span class="linenr">4:  </span>((lambda (p q) p) x y)
<span class="linenr">5:  </span>x
</pre>



</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 习题</h3>
<div class="outline-text-3" id="text-3-1">

<p>Exercise 2.5.  Show that we can represent pairs of nonnegative integers using only numbers and arithmetic operations if we represent the pair a and b as the integer that is the product 2<sup>a</sup> 3<sup>b</sup>. Give the corresponding definitions of the procedures cons, car, and cdr.
</p>
<p>
2<sup>a</sup>3<sup>b</sup>   = 2*2*2*2*&hellip;*2    *  3*3* &hellip; *3*3  
</p>
<p>
当2<sup>a</sup>3<sup>b</sup>除以2结果得分数，就证明2除尽了，同理除以3结果得分数后，3也除尽了，根据这个算a和b
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">our-cons</span> (a b)
<span class="linenr"> 2:  </span>  (* (expt 2 a)
<span class="linenr"> 3:  </span>     (expt 3 b)))
<span class="linenr"> 4:  </span>
<span class="linenr"> 5:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">our-car</span> (z)
<span class="linenr"> 6:  </span>  (divide-times z 2)))
<span class="linenr"> 7:  </span>
<span class="linenr"> 8:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">our-cdr</span> (z)
<span class="linenr"> 9:  </span>  (divide-times z 3)))
<span class="linenr">10:  </span>
<span class="linenr">11:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">divide-times</span> (number divisor)
<span class="linenr">12:  </span>  (<span style="color: #a020f0;">labels</span> ((iter (n result)
<span class="linenr">13:  </span>             (<span style="color: #a020f0;">let</span> ((tmp (/ n divisor)))
<span class="linenr">14:  </span>               (<span style="color: #a020f0;">if</span> (integerp tmp)
<span class="linenr">15:  </span>                   (iter tmp (1+ result))
<span class="linenr">16:  </span>                   result))))
<span class="linenr">17:  </span>    (iter number 0)))
</pre>


<p>
Exercise 2.6.  In case representing pairs as procedures wasn't mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as
</p>


<pre class="src src-scheme"><span class="linenr">1:  </span>(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">zero</span> (<span style="color: #a020f0;">lambda</span> (f) (<span style="color: #a020f0;">lambda</span> (x) x)))
<span class="linenr">2:  </span>
<span class="linenr">3:  </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">add-1</span> n)
<span class="linenr">4:  </span>  (<span style="color: #a020f0;">lambda</span> (f) (<span style="color: #a020f0;">lambda</span> (x) (f ((n f) x)))))
</pre>

<p>
This representation is known as Church numerals, after its inventor, Alonzo Church, the logician who invented the  calculus.
</p>
<p>
Define one and two directly (not in terms of zero and add-1). (Hint: Use substitution to evaluate (add-1 zero)). Give a direct definition of the addition procedure + (not in terms of repeated application of add-1).
</p>
<p>
置换过程
</p>


<pre class="example"><span class="linenr">1:  </span>(lambda (f) (lambda (x) x)) -- zero
<span class="linenr">2:  </span>
<span class="linenr">3:  </span>(add-1 zero)
<span class="linenr">4:  </span>(lambda (f) (lambda (x) (f ((zero f) x))))
<span class="linenr">5:  </span>(lambda (f) (lambda (x) (f x))) -- one
</pre>

<p>
这个主要是对参数x做几次f，zero就是做0次 ，one 做1次&hellip;
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">zero</span> ()
<span class="linenr"> 2:  </span>  (<span style="color: #a020f0;">lambda</span> (f) (<span style="color: #a020f0;">lambda</span> (x) x)))
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">one</span> ()
<span class="linenr"> 5:  </span>  (<span style="color: #a020f0;">lambda</span> (f) (<span style="color: #a020f0;">lambda</span> (x) (funcall f x))))
<span class="linenr"> 6:  </span>
<span class="linenr"> 7:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">two</span> ()
<span class="linenr"> 8:  </span>  (<span style="color: #a020f0;">lambda</span> (f)
<span class="linenr"> 9:  </span>    (<span style="color: #a020f0;">lambda</span> (x)
<span class="linenr">10:  </span>      (funcall f (funcall f x)))))
<span class="linenr">11:  </span>
<span class="linenr">12:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">our-+</span> (n1 n2)
<span class="linenr">13:  </span>  (<span style="color: #a020f0;">lambda</span> (f)
<span class="linenr">14:  </span>    (<span style="color: #a020f0;">lambda</span> (x)
<span class="linenr">15:  </span>      (funcall (funcall (funcall n1) f)
<span class="linenr">16:  </span>               (funcall (funcall (funcall n2) f) x)))))
</pre>

<p>
这个只有两个参数的+版本，下面实现下多个参数的+版本
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">our-+</span> (<span style="color: #228b22;">&amp;rest</span> ns)
<span class="linenr"> 2:  </span>  (<span style="color: #a020f0;">labels</span> ((rec (n lst f x)
<span class="linenr"> 3:  </span>             (<span style="color: #a020f0;">if</span> (null lst)
<span class="linenr"> 4:  </span>                 (funcall (funcall (funcall n) f) x)
<span class="linenr"> 5:  </span>                 (funcall (funcall (funcall n) f)
<span class="linenr"> 6:  </span>                          (rec (car lst)
<span class="linenr"> 7:  </span>                               (cdr lst)
<span class="linenr"> 8:  </span>                               f
<span class="linenr"> 9:  </span>                               x)))))
<span class="linenr">10:  </span>    (<span style="color: #a020f0;">lambda</span> (f)
<span class="linenr">11:  </span>      (<span style="color: #a020f0;">lambda</span> (x)
<span class="linenr">12:  </span>        (rec (car ns) (cdr ns) f x)))))
</pre>

</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 扩展练习：区间算术</h2>
<div class="outline-text-2" id="text-4">

<p>电阻公式：
<img src="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-8.gif"  alt="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-8.gif" />
</p>
<p>
电阻一般都有一定的误差。Alyssa想实现一套“区间算术”，两个区间的加、减、乘、除的结果仍是一个区间，表示的是计算结果的范围。
Alyssa假设有一种称为“区间”的抽象对象，这种对象有两个端点，下界和上界。
Alyssa设计了加、乘、除函数：
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-interval</span> (x y)
<span class="linenr"> 2:  </span>  (make-interval (+ (lower-bound x) (lower-bound y))
<span class="linenr"> 3:  </span>                 (+ (upper-bound x) (upper-bound y))))
<span class="linenr"> 4:  </span>
<span class="linenr"> 5:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">mul-interval</span> (x y)
<span class="linenr"> 6:  </span>  (<span style="color: #a020f0;">let</span> ((p1 (* (lower-bound x) (lower-bound y)))
<span class="linenr"> 7:  </span>        (p2 (* (lower-bound x) (upper-bound y)))
<span class="linenr"> 8:  </span>        (p3 (* (upper-bound x) (lower-bound y)))
<span class="linenr"> 9:  </span>        (p4 (* (upper-bound x) (upper-bound y))))
<span class="linenr">10:  </span>    (make-interval (min p1 p2 p3 p4)
<span class="linenr">11:  </span>                   (max p1 p2 p3 p4))))
<span class="linenr">12:  </span>
<span class="linenr">13:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">div-interval</span> (x y)
<span class="linenr">14:  </span>  (mul-interval x
<span class="linenr">15:  </span>                (make-interval (/ 1.0 (upper-bound y))
<span class="linenr">16:  </span>                               (/ 1.0 (lower-bound y)))))
</pre>



</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 习题</h3>
<div class="outline-text-3" id="text-4-1">

<p>Exercise 2.7.  Alyssa's program is incomplete because she has not specified the implementation of the interval abstraction. Here is a definition of the interval constructor:
</p>
<p>
(define (make-interval a b) (cons a b))
</p>
<p>
Define selectors upper-bound and lower-bound to complete the implementation.
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-interval</span> (a b) (cons a b))
<span class="linenr">2:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">lower-bound</span> (x) (car x))
<span class="linenr">3:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">upper-bound</span> (x) (cdr x))
</pre>


<p>
Exercise 2.8.  Using reasoning analogous to Alyssa's, describe how the difference of two intervals may be computed. Define a corresponding subtraction procedure, called sub-interval.
</p>
<p>
两个区间相减等于一个区间加上被减区间的负数。测试make-interval传递参数的时候注意：大小参数顺序不能乱
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">sub-interval</span> (x y)
<span class="linenr">2:  </span>  (add-interval x
<span class="linenr">3:  </span>                (make-interval (- (upper-bound y))
<span class="linenr">4:  </span>                               (- (lower-bound y)))))
</pre>

<p>
也可以直接做减运算，只要注意把被减的区间upper和lower调换一下
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">sub-interval</span> (x y)
<span class="linenr">2:  </span>  (make-interval (- (lower-bound x) (upper-bound y))
<span class="linenr">3:  </span>                 (- (upper-bound x) (lower-bound y))))
</pre>


<p>
Exercise 2.9.  The width of an interval is half of the difference between its upper and lower bounds. The width is a measure of the uncertainty of the number specified by the interval. For some arithmetic operations the width of the result of combining two intervals is a function only of the widths of the argument intervals, whereas for others the width of the combination is not a function of the widths of the argument intervals. Show that the width of the sum (or difference) of two intervals is a function only of the widths of the intervals being added (or subtracted). Give examples to show that this is not true for multiplication or division.
</p>

<p class="verse">
x=[x<sub>l</sub>,x<sub>u</sub>] y=[y<sub>l</sub>,y<sub>u</sub>]<br/>
<br/>
sum-width:<br/>
1/2 * ((x<sub>u</sub> + y<sub>u</sub>) - (x<sub>l</sub> + y<sub>l</sub>))<br/>
1/2 * ((x<sub>u</sub> - x<sub>l</sub>) + (y<sub>u</sub> - y<sub>l</sub>))<br/>
width of interval x + width of interval y<br/>
<br/>
sub-width:<br/>
1/2 * ((x<sub>u</sub> - y<sub>l</sub>) - (x<sub>l</sub> - y<sub>u</sub>))<br/>
1/2 * ((x<sub>u</sub> - x<sub>l</sub>) + (y<sub>u</sub> - y<sub>l</sub>))<br/>
width of interval x + width of interval y<br/>
<br/>
mul-width:<br/>
[1,10] * [0,5] = [0,50] (width = 25)<br/>
</p>


<p>
Exercise 2.10.  Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and comments that it is not clear what it means to divide by an interval that spans zero. Modify Alyssa's code to check for this condition and to signal an error if it occurs.
</p>



<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">div-interval</span> (x y)
<span class="linenr">2:  </span>  (<span style="color: #a020f0;">if</span> (and (&gt;= (upper-bound y) 0)
<span class="linenr">3:  </span>           (&lt;= (lower-bound y) 0))
<span class="linenr">4:  </span>      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"interval spans zero"</span>)
<span class="linenr">5:  </span>      (mul-interval x
<span class="linenr">6:  </span>                    (make-interval (/ 1.0 (upper-bound y))
<span class="linenr">7:  </span>                                   (/ 1.0 (lower-bound y)))))
</pre>


<p>
Exercise 2.11.  In passing, Ben also cryptically comments: ``By testing the signs of the endpoints of the intervals, it is possible to break mul-interval into nine cases, only one of which requires more than two multiplications.'' Rewrite this procedure using Ben's suggestion.
</p>



<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">mul-interval</span> (x y)
<span class="linenr"> 2:  </span>  (<span style="color: #a020f0;">let</span> ((xl (lower-bound x))
<span class="linenr"> 3:  </span>        (xu (upper-bound x))
<span class="linenr"> 4:  </span>        (yl (lower-bound y))
<span class="linenr"> 5:  </span>        (yu (upper-bound y)))
<span class="linenr"> 6:  </span>    <span style="color: #b22222;">;; </span><span style="color: #b22222;">xl&#21644;xu&#19982;yl&#21644;yu &#21516;&#21495;&#30340;&#22235;&#31181;&#24773;&#20917;</span>
<span class="linenr"> 7:  </span>    <span style="color: #b22222;">;; </span><span style="color: #b22222;">x++ y++; x++ y--; x-- y++; x-- y--</span>
<span class="linenr"> 8:  </span>    (<span style="color: #a020f0;">cond</span> ((and (&gt;= xl 0) <span style="color: #b22222;">; </span><span style="color: #b22222;">x++ y++</span>
<span class="linenr"> 9:  </span>                (&gt;= yl 0))
<span class="linenr">10:  </span>           (make-interval (* xl yl) (* xu yu)))
<span class="linenr">11:  </span>          ((and (&gt;= xl 0) <span style="color: #b22222;">; </span><span style="color: #b22222;">x++ y--</span>
<span class="linenr">12:  </span>                (&lt;= yu 0))
<span class="linenr">13:  </span>           (make-interval (* xu yl) (* xl yu)))
<span class="linenr">14:  </span>          ((and (&lt;= xu 0) <span style="color: #b22222;">; </span><span style="color: #b22222;">x-- y++</span>
<span class="linenr">15:  </span>                (&gt;= yl 0))
<span class="linenr">16:  </span>           (make-interval (* xl yu) (* xu yl)))
<span class="linenr">17:  </span>          ((and (&lt;= xu 0) <span style="color: #b22222;">; </span><span style="color: #b22222;">x-- y--</span>
<span class="linenr">18:  </span>                (&lt;= yu 0))
<span class="linenr">19:  </span>           (make-interval (* xl yl) (* xu yu)))
<span class="linenr">20:  </span>    <span style="color: #b22222;">;; </span><span style="color: #b22222;">&#21333;&#24322;&#65306;xl&#21644;xu&#24322;&#21495;&#65292;y &#21516;&#21495;&#12290;&#25110;&#32773;&#30456;&#21453;&#12290;&#22235;&#31181;&#24773;&#20917;</span>
<span class="linenr">21:  </span>    <span style="color: #b22222;">;; </span><span style="color: #b22222;">x-+ y++; x-+ y--; x++ y-+; x-- y-+</span>
<span class="linenr">22:  </span>          ((and (&lt;= xl 0) <span style="color: #b22222;">; </span><span style="color: #b22222;">x-+ y++</span>
<span class="linenr">23:  </span>                (&gt;= xu 0)
<span class="linenr">24:  </span>                (&gt;= yl 0))
<span class="linenr">25:  </span>           (make-interval (* xl yu) (* xu yu)))
<span class="linenr">26:  </span>          ((and (&lt;= xl 0) <span style="color: #b22222;">; </span><span style="color: #b22222;">x-+ y--</span>
<span class="linenr">27:  </span>                (&gt;= xu 0)
<span class="linenr">28:  </span>                (&lt;= yu 0))
<span class="linenr">29:  </span>           (make-interval (* xu yl) (* xl yl)))
<span class="linenr">30:  </span>          ((and (&gt;= xl 0) <span style="color: #b22222;">; </span><span style="color: #b22222;">x++ y-+</span>
<span class="linenr">31:  </span>                (&lt;= yl 0)
<span class="linenr">32:  </span>                (&gt;= yu 0))
<span class="linenr">33:  </span>           (make-interval (* xu yl) (* xu yu)))
<span class="linenr">34:  </span>          ((and (&lt;= xu 0) <span style="color: #b22222;">; </span><span style="color: #b22222;">x-- y-+</span>
<span class="linenr">35:  </span>                (&lt;= yl 0)
<span class="linenr">36:  </span>                (&gt;= yu 0))
<span class="linenr">37:  </span>           (make-interval (* xl yu) (* xl yl)))
<span class="linenr">38:  </span>    <span style="color: #b22222;">;; </span><span style="color: #b22222;">&#21452;&#24322;&#65292;&#36825;&#31181;&#23601;&#26159;&#22810;&#20313;&#20004;&#27425;&#20056;</span>
<span class="linenr">39:  </span>    <span style="color: #b22222;">;; </span><span style="color: #b22222;">&#35805;&#35828;&#20013;&#25991;&#32763;&#35793;&#30495;&#27700;&#21834;&#65292;&#23621;&#28982;&#32763;&#35793;&#20056;&#27599;&#31181;&#37117;&#19981;&#23569;&#20110;&#20004;&#27425;&#12290;</span>
<span class="linenr">40:  </span>          ((and (&lt;= xl 0) <span style="color: #b22222;">; </span><span style="color: #b22222;">x-+ y-+</span>
<span class="linenr">41:  </span>                (&gt;= xu 0)
<span class="linenr">42:  </span>                (&lt;= yl 0)
<span class="linenr">43:  </span>                (&gt;= yu 0))
<span class="linenr">44:  </span>           (<span style="color: #a020f0;">let</span> ((p1 (* xl yl))
<span class="linenr">45:  </span>                 (p2 (* xl yu))
<span class="linenr">46:  </span>                 (p3 (* xu yl))
<span class="linenr">47:  </span>                 (p4 (* xu yu)))
<span class="linenr">48:  </span>             (make-interval (min p2 p3)
<span class="linenr">49:  </span>                            (max p1 p4)))))))
</pre>


<p>
Exercise 2.12.  After debugging her program, Alyssa shows it to a potential user, who complains that her program solves the wrong problem. He wants a program that can deal with numbers represented as a center value and an additive tolerance; for example, he wants to work with intervals such as 3.5± 0.15 rather than [3.35, 3.65]. Alyssa returns to her desk and fixes this problem by supplying an alternate constructor and alternate selectors:
</p>



<pre class="src src-scheme"><span class="linenr">1:  </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">make-center-width</span> c w)
<span class="linenr">2:  </span>  (make-interval (- c w) (+ c w)))
<span class="linenr">3:  </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">center</span> i)
<span class="linenr">4:  </span>  (/ (+ (lower-bound i) (upper-bound i)) 2))
<span class="linenr">5:  </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">width</span> i)
<span class="linenr">6:  </span>  (/ (- (upper-bound i) (lower-bound i)) 2))
</pre>


<p>
Unfortunately, most of Alyssa's users are engineers. Real engineering situations usually involve measurements with only a small uncertainty, measured as the ratio of the width of the interval to the midpoint of the interval. Engineers usually specify percentage tolerances on the parameters of devices, as in the resistor specifications given earlier.
</p>
<p>
Define a constructor make-center-percent that takes a center and a percentage tolerance and produces the desired interval. You must also define a selector percent that produces the percentage tolerance for a given interval. The center selector is the same as the one shown above.
</p>



<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-center-percent</span> (c p)
<span class="linenr"> 2:  </span>  (<span style="color: #a020f0;">let</span> ((tolerance (* c p)))
<span class="linenr"> 3:  </span>    (make-interval (- c tolerance)
<span class="linenr"> 4:  </span>                   (+ c tolerance))))
<span class="linenr"> 5:  </span>
<span class="linenr"> 6:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">percent</span> (i)
<span class="linenr"> 7:  </span>  (/ (width i) (center i)))
<span class="linenr"> 8:  </span>
<span class="linenr"> 9:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-center-width</span> (c w)
<span class="linenr">10:  </span>  (make-interval (- c w) (+ c w)))
<span class="linenr">11:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">center</span> (i)
<span class="linenr">12:  </span>  (/ (+ (lower-bound i) (upper-bound i)) 2))
<span class="linenr">13:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">width</span> (i)
<span class="linenr">14:  </span>  (/ (- (upper-bound i) (lower-bound i)) 2))
</pre>


<p>
Exercise 2.13.  Show that under the assumption of small percentage tolerances there is a simple formula for the approximate percentage tolerance of the product of two intervals in terms of the tolerances of the factors. You may simplify the problem by assuming that all numbers are positive.
</p>

<p class="verse">
有两个区间i<sub>1</sub>和i<sub>2</sub>，假设i<sub>3</sub> = i<sub>1</sub> * i<sub>2</sub> （所有数都为正数）<br/>
i<sub>1</sub> = [c<sub>1</sub> * (1 - p<sub>1</sub>), c<sub>1</sub> * (1 + p<sub>1</sub>)]<br/>
i<sub>2</sub> = [c<sub>2</sub> * (1 - p<sub>2</sub>), c<sub>2</sub> * (1 + p<sub>2</sub>)]<br/>
i<sub>3</sub> = <br/>
[c<sub>1</sub> * c<sub>2</sub> * (1 - (p<sub>1</sub> + p<sub>2</sub>) + p<sub>1</sub> * p<sub>2</sub>),<br/>
c<sub>1</sub> * c<sub>2</sub> * (1 + (p<sub>1</sub> + p<sub>2</sub>) + p<sub>1</sub> * p<sub>2</sub>)]<br/>
p<sub>1</sub>和p<sub>2</sub>都很小，那么p<sub>1</sub> * p<sub>2</sub>就可以忽略，那么p<sub>3</sub> = p<sub>1</sub> + p<sub>2</sub><br/>
</p>


<p>
Exercise 2.14.  After considerable work, Alyssa P. Hacker delivers her finished system. Several years later, after she has forgotten all about it, she gets a frenzied call from an irate user, Lem E. Tweakit. It seems that Lem has noticed that the formula for parallel resistors can be written in two algebraically equivalent ways:
</p>
<p>
<img src="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-9.gif"  alt="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-9.gif" />
</p>
<p>
and
</p>
<p>
<img src="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-10.gif"  alt="http://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-10.gif" />
</p>
<p>
He has written the following two programs, each of which computes the parallel-resistors formula differently:
</p>



<pre class="src src-scheme"><span class="linenr">1:  </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">par1</span> r1 r2)
<span class="linenr">2:  </span>  (div-interval (mul-interval r1 r2)
<span class="linenr">3:  </span>                (add-interval r1 r2)))
<span class="linenr">4:  </span>(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">par2</span> r1 r2)
<span class="linenr">5:  </span>  (<span style="color: #a020f0;">let</span> ((one (make-interval 1 1))) 
<span class="linenr">6:  </span>    (div-interval one
<span class="linenr">7:  </span>                  (add-interval (div-interval one r1)
<span class="linenr">8:  </span>                                (div-interval one r2)))))
</pre>


<p>
Lem complains that Alyssa's program gives different answers for the two ways of computing. This is a serious complaint.
</p>
<p>
Demonstrate that Lem is right. Investigate the behavior of the system on a variety of arithmetic expressions. Make some intervals A and B, and use them in computing the expressions A/A and A/B. You will get the most insight by using intervals whose width is a small percentage of the center value. Examine the results of the computation in center-percent form (see exercise 2.12).
</p>

<p class="verse">
r1 = [r1<sub>L</sub>, r1<sub>U</sub>]，r2 = [r2<sub>L</sub>, r2<sub>U</sub>]<br/>
par1 = (r1 * r2) / (r1 + r2)<br/>
[r1<sub>L</sub>r2<sub>L</sub>, r1<sub>U</sub>r2<sub>U</sub>] / [r1<sub>L</sub> + r2<sub>L</sub>, r1<sub>U</sub> + r2<sub>U</sub>]<br/>
[(r1<sub>L</sub>r2<sub>L</sub>) / (r1<sub>U</sub> + r2<sub>U</sub>), (r1<sub>U</sub>r2<sub>U</sub>) / (r1<sub>L</sub> + r2<sub>L</sub>)]<br/>
par2 = [(r1<sub>L</sub>r2<sub>L</sub>) / (r1<sub>L</sub> + r2<sub>L</sub>), (r1<sub>U</sub>r2<sub>U</sub>) / (r1<sub>U</sub> + r2<sub>U</sub>)]<br/>
par1与par2不相等，Lem is right<br/>
</p>


<p>
下面定义区间A，对于区间来说A/A并不等于1,而值还是在区间之间
</p>
<p class="verse">
CL-USER&gt; (defparameter *A* (make-center-percent 5 .03))<br/>
*A*<br/>
CL-USER&gt; *A*<br/>
(4.85 . 5.15)<br/>
CL-USER&gt; (div-interval *A* *A*)<br/>
(0.94174755 . 1.0618557)<br/>
</p>


<p>
所以对于区间来说：
R<sub>1</sub>R<sub>2</sub>/(R<sub>1</sub>+R<sub>2</sub>) /= 1/(1/R<sub>1</sub> + 1/R<sub>2</sub>)
第二个公式分子分母都乘以R<sub>1</sub>R<sub>2</sub>，就是乘以了R<sub>1</sub>R<sub>2</sub>/R<sub>1</sub>R<sub>2</sub>，但它并不等于1,所以这么乘的时候已经使第二个公式变成另外一个值。
</p>
<p>
Exercise 2.15.  Eva Lu Ator, another user, has also noticed the different intervals computed by different but algebraically equivalent expressions. She says that a formula to compute with intervals using Alyssa's system will produce tighter error bounds if it can be written in such a form that no variable that represents an uncertain number is repeated. Thus, she says, par2 is a ``better'' program for parallel resistances than par1. Is she right? Why?
</p>
<p>
Eva Lu Ator is right。因为第一个公式中，R<sub>1</sub>与R<sub>2</sub>（另一个区间）做乘，做加，这样增加了这个区间的变化，增加了不确定性，不像第二个公式，与1做运算，区间变化较小，而且R<sub>1</sub>与R<sub>2</sub>只出现一次，相对第一个公式，不确定性减少。
</p>
<p>
Exercise 2.16.  Explain, in general, why equivalent algebraic expressions may lead to different answers. Can you devise an interval-arithmetic package that does not have this shortcoming, or is this task impossible? (Warning: This problem is very difficult.)
</p>
<p>
这个问题之前练习中有说道，对于数学上的R/R=1,但对于区间R/R是以1为中心带有偏差的区间，这就不是1了，所以在区间上乘以R/R本身就不是乘以1,自然公式转换就变了值。
</p>
<p>
解决先算了，还是继续向下看把:)
</p>
</div>
</div>
</div>
</div>




<div id="postamble">
<p class="date">Date: 2014-10-23T08:11+0800</p>
<p class="author">Author: leon</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
