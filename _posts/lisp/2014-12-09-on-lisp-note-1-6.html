---
layout: post
title: On Lisp 笔记 - 有关函数
category: lisp
description: on lisp 的1-6章笔记，只想看过后可以快速复习，不知不觉几乎几下了原文...
---

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>On Lisp 笔记 - 有关函数（1-6章）</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="On Lisp 笔记 - 有关函数（1-6章）"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-12-09T19:40+0800"/>
<meta name="author" content="leon"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">On Lisp 笔记 - 有关函数（1-6章）</h1>



<p>
自底向上的编程方法：一个自底向上的程序由一系列的层写成，每一层都作为更高一层的编程语言。自底向上的编程方法是lisp与生俱来的强项。
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 可扩展语言</a>
<ul>
<li><a href="#sec-1-1">1.1 渐进式设计</a></li>
<li><a href="#sec-1-2">1.2 自底向上程序设计</a></li>
<li><a href="#sec-1-3">1.3 可扩展软件</a></li>
<li><a href="#sec-1-4">1.4 扩展Lisp</a></li>
</ul>
</li>
<li><a href="#sec-2">2 函数</a>
<ul>
<li><a href="#sec-2-1">2.1 作为数据的函数</a></li>
<li><a href="#sec-2-2">2.2 定义函数</a></li>
<li><a href="#sec-2-3">2.3 函数型参数</a></li>
<li><a href="#sec-2-4">2.4 作为属性的函数</a></li>
<li><a href="#sec-2-5">2.5 作用域</a></li>
<li><a href="#sec-2-6">2.6 闭包</a></li>
<li><a href="#sec-2-7">2.7 局部函数</a></li>
<li><a href="#sec-2-8">2.8 尾递归</a></li>
<li><a href="#sec-2-9">2.9 编译</a></li>
<li><a href="#sec-2-10">2.10 来自列表的函数</a></li>
</ul>
</li>
<li><a href="#sec-3">3 函数式编程</a>
<ul>
<li><a href="#sec-3-1">3.1 函数式设计</a></li>
<li><a href="#sec-3-2">3.2 内外颠倒的命令式</a></li>
<li><a href="#sec-3-3">3.3 函数式接口</a></li>
<li><a href="#sec-3-4">3.4 交互式编程</a></li>
</ul>
</li>
<li><a href="#sec-4">4 实用函数</a>
<ul>
<li><a href="#sec-4-1">4.1 实用工具的诞生</a></li>
<li><a href="#sec-4-2">4.2 投资抽象</a></li>
<li><a href="#sec-4-3">4.3 列表上的操作</a>
<ul>
<li><a href="#sec-4-3-1">4.3.1 列表实用工具</a></li>
</ul>
</li>
<li><a href="#sec-4-4">4.4 搜索</a></li>
<li><a href="#sec-4-5">4.5 映射</a></li>
<li><a href="#sec-4-6">4.6 I/O</a></li>
<li><a href="#sec-4-7">4.7 符号和字符串</a></li>
<li><a href="#sec-4-8">4.8 紧凑性</a></li>
</ul>
</li>
<li><a href="#sec-5">5 函数作为返回值</a>
<ul>
<li><a href="#sec-5-1">5.1 Common Lisp 的演化</a></li>
<li><a href="#sec-5-2">5.2 正交性</a></li>
<li><a href="#sec-5-3">5.3 记住过去</a></li>
<li><a href="#sec-5-4">5.4 复合函数</a></li>
<li><a href="#sec-5-5">5.5 在cdr上递归</a></li>
<li><a href="#sec-5-6">5.6 在子树上递归</a></li>
<li><a href="#sec-5-7">5.7 何时构造函数</a></li>
</ul>
</li>
<li><a href="#sec-6">6 函数作为表达方式</a>
<ul>
<li><a href="#sec-6-1">6.1 网络</a></li>
<li><a href="#sec-6-2">6.2 编译后的网络</a></li>
<li><a href="#sec-6-3">6.3 展望</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 可扩展语言</h2>
<div class="outline-text-2" id="text-1">



</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 渐进式设计</h3>
<div class="outline-text-3" id="text-1-1">

<p>常规的做事方式：
</p><ol>
<li>仔细计划你打算做的事情
</li>
<li>去执行它
</li>
</ol>


<p>
但写程序可能就不太适用，程序变数很多，想计划好一切不太现实。lisp允许你遍写程序边做计划。如果要理清自己的思路，试着把它写下来会是最好的方法。边设计边施工有两个重要的后果：程序可以花更少的时间去写，因为当你把计划和实际动手写放在一起的时候，你总可以把精力集中在一个实际的程序上，然后让它日益完善，因为最终的设计必定是进化的成果。只要在把握你程序的命运时坚持一个原则：一旦定位错误的地方，就立即重写它，那么最终的产品将会比事先你花几个星期的时间精心设计的结果更加优雅。
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 自底向上程序设计</h3>
<div class="outline-text-3" id="text-1-2">

<p>自顶向上设计：你说“这个程序的目的是完成这七件事，那么我就把它分成七个主要的子例程。第一个子例程要做四件事，所以它将进一步细分成它自己的四个子例程”，如此这般。
</p>
<p>
自底向上的设计原则——即通过改变语言来适应程序。有几点好处：
</p><ol>
<li>通过让语言担当更多的工作，自底向上设计产生的程序会更加短小轻快。一个更短小的程序就不必划分成那么多的组件了，并且更少的组件意味着程序会更易于阅读和修改。更少的组件也使得组件之间的连接会更少，因而错误发生的机会也会相应减少。一个机械设计师往往努力去减少机器上运动部件的数量，同样有经验的Lisp程序员使用自底向上的设计方法来减小他们程序的规模和复杂度。
</li>
<li>自底向上的设计促进了代码重用。当你写两个或更多程序时，许多你为第一个程序写的工具也会对之后的程序开发有帮助。一旦积累下了雄厚的工具基础，写一个新程序所耗费的精力和从最初Lisp环境白手起家相比，前者可能只是后者的几分之一。
</li>
<li>自底向上提高了程序的可读性。
</li>
<li>由于自底向上的设计驱使你总是去关注代码中的模式，这种工作方式有助于理清设计程序时的思路。如果一个程序中两个关系很远的组件在形式上很相似，你就会因此注意到这种相似性，然后也许会以更简单的方式重新设计程序。
</li>
</ol>


</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 可扩展软件</h3>
<div class="outline-text-3" id="text-1-3">

<p>如果我们不能给用户一个现成的软件，让它能完成用户想要的每个功能，那么我们也可以交付一个可扩展的软件。
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> 扩展Lisp</h3>
<div class="outline-text-3" id="text-1-4">

<p>有两种方式可以为Lisp增加新的操作符：函数和宏。
</p>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 函数</h2>
<div class="outline-text-2" id="text-2">

<p>除了少数称为特殊形式（special form）的操作符之外，Lisp的核心就是一个函数的集合。在Lisp里，+和你自己定义的函数一样，也是个函数。
</p>

</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 作为数据的函数</h3>
<div class="outline-text-3" id="text-2-1">

<p>Lisp中函数作为一种数据类型，像整数那样：在运行期创建一个新函数，把函数保存在变量和结构体里面，作为参数传递，作为函数的返回值。
</p>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 定义函数</h3>
<div class="outline-text-3" id="text-2-2">

<p>defun并不只是过程定义，它们还是Lisp调用。同时，函数本身也是对象。defun实际所做的就是构造这样的对象，然后把它保存在第一个参数名下。Common Lisp的函数是第一类（first-class）对象，它和整数和字符串这些更熟悉的对象享有完全相同的权利。
</p>
<p>
在Common Lisp里，我们可以同时拥有名为double的函数和变量。当名字出现在函数调用的首位，或者前置#'的时候，他被认为是函数。其他场合下它被当成变量名。因此我们说Common Lisp拥有独立的函数和变量名字空间（name-space）。Common Lisp提供了两个函数用于将符号映射到它所代表的函数或者变量：symbol-function和symbol-value。深入分析的话，defun实际上是把它第一个参数的symbol-function设置成了用它其余部分构造的函数：
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">double</span> (x) (* x 2))
<span class="linenr">2:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#20004;&#20010;&#34920;&#36798;&#24335;&#23436;&#25104;&#30340;&#21151;&#33021;&#22522;&#26412;&#30456;&#21516;</span>
<span class="linenr">3:  </span>(setf (symbol-function 'double)
<span class="linenr">4:  </span>      #' (<span style="color: #a020f0;">lambda</span> (x) (* x 2)))
</pre>


</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 函数型参数</h3>
<div class="outline-text-3" id="text-2-3">

<p>无论是使用内置的工具，比如sort，还是编写你的实用工具，基本原则是一样的：与其把功能写死，不如传进去一个函数参数。
</p>
</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 作为属性的函数</h3>
<div class="outline-text-3" id="text-2-4">

<p>函数作为Lisp对象这一事实也创造了条件，让我们能够编写出那种可以随时扩展以满足新需求的程序。假设我们需要写一个以动物种类作为参数并产生相应行为的函数。在大多数语言中，会使用case语句达到这个目的，Lisp里也可以用同样的办法：
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">behave</span> (animal)
<span class="linenr">2:  </span>  (<span style="color: #a020f0;">case</span> animal
<span class="linenr">3:  </span>    (dog (wag-tail)
<span class="linenr">4:  </span>         (bark))
<span class="linenr">5:  </span>    (rat (scurry)
<span class="linenr">6:  </span>         (squeak))
<span class="linenr">7:  </span>    (cat (rub-legs)
<span class="linenr">8:  </span>         (scratch-carpet))))
</pre>

<p>
如果要增加一种新动物该怎么办呢？如果计划增加新的动物，那么把behave定义成下面的样子可能会更好一些：
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">behave</span> (animal)
<span class="linenr">2:  </span>  (funcall (get animal &#8217;behavior)))
</pre>

<p>
同时把每种个体动物的行为以单独的函数形式保存，例如，存放在以它们名字命名的属性列表里：
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(setf (get &#8217;dog &#8217;behavior)
<span class="linenr">2:  </span>      #&#8217;(<span style="color: #a020f0;">lambda</span> ()
<span class="linenr">3:  </span>           (wag-tail)
<span class="linenr">4:  </span>           (bark)))
</pre>

<p>
用这种方式处理的话，要增加一种新动物，所有你需要做的事情就是定义一个新的属性。一个函数都不用写。
</p>
<p>
不过这种方式会慢一些，如果速度很关键，我们可以把属性表换成结构体，而且特别要用编译过的函数代替解释性的函数。（到2.9节看怎样做到这些）使用了结构体和编译函数，其速度可以达到甚至超过那些使用case语句的实现。当然面向对象中的方法和继承也可以很好的实现上述扩展，如果我们要的可扩展性不是很依赖继承，那么纯Lisp可能就已经足够应付了。
</p>
</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> 作用域</h3>
<div class="outline-text-3" id="text-2-5">

<p>Common Lisp是词法作用域(lexically scope)的Lisp
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">let</span> ((y 7))
<span class="linenr">2:  </span>  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">scope-test</span> (x)
<span class="linenr">3:  </span>    (list x y)))
<span class="linenr">4:  </span>
<span class="linenr">5:  </span>(<span style="color: #a020f0;">let</span> ((y 5))
<span class="linenr">6:  </span>  (scope-test 3))
<span class="linenr">7:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#21160;&#24577;&#20316;&#29992;&#22495; (3 5)</span>
<span class="linenr">8:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#35789;&#27861;&#20316;&#29992;&#22495; (3 7)</span>
</pre>

</div>

</div>

<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> 闭包</h3>
<div class="outline-text-3" id="text-2-6">

<p>由于Common Lisp是词法作用域的，所以如果定义含有自由变量的函数（如上节中y），系统就必须在函数定义时保存那些变量的绑定。这种函数和一组变量绑定的组合称为闭包。
</p></div>

</div>

<div id="outline-container-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> 局部函数</h3>
<div class="outline-text-3" id="text-2-7">




<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">test-labels</span> (x)
<span class="linenr">2:  </span>  (<span style="color: #a020f0;">labels</span> ((name (parameters)
<span class="linenr">3:  </span>             (body)))
<span class="linenr">4:  </span>    (name parameters)))
</pre>

</div>

</div>

<div id="outline-container-2-8" class="outline-3">
<h3 id="sec-2-8"><span class="section-number-3">2.8</span> 尾递归</h3>
<div class="outline-text-3" id="text-2-8">

<p>如果这个函数调用自己之后不做其他工作，这种调用就称为尾递归（tail-recursive）。
许多cl编译器都可以把尾递归转化成循环，这样就不必担心函数调用在运行期产生的系统开销。
如果一个函数不是尾递归的话，常常可以把一个使用累积器（accumulator）的局部函数嵌入其中，用这种方法把它转换成尾递归形式。
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">our-length</span> (lst)
<span class="linenr">2:  </span>  (<span style="color: #a020f0;">labels</span> ((rec (lst acc)
<span class="linenr">3:  </span>             (<span style="color: #a020f0;">if</span> (null lst)
<span class="linenr">4:  </span>                 acc
<span class="linenr">5:  </span>                 (rec (cdr lst) (1+ acc)))))
<span class="linenr">6:  </span>    (rec lst 0)))
</pre>

<p>
许多cl编译器都能做尾递归优化，但这并不是所有编译器的默认行为。所以在编写尾递归函数时，应该把以下这句写在文件的最前面，确保编译器不会辜负你的苦心，进行期望的优化。
</p><pre class="example">
(proclaim '(optimize speed))
</pre>

<p>如果提供尾递归和类型声明，现有的cl编译器就能生成运行速度能与c程序相媲美，甚至超过它的代码。下面代码从1累加到n：
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">triangle</span> (n)
<span class="linenr">2:  </span>  (<span style="color: #a020f0;">labels</span> ((tri (c n)
<span class="linenr">3:  </span>             (<span style="color: #a020f0;">declare</span> (type fixnum n c))
<span class="linenr">4:  </span>             (<span style="color: #a020f0;">if</span> (zerop n)
<span class="linenr">5:  </span>                 c
<span class="linenr">6:  </span>                 (tri (<span style="color: #a020f0;">the</span> fixnum (+ n c))
<span class="linenr">7:  </span>                      (<span style="color: #a020f0;">the</span> fixnum (- n 1))))))
<span class="linenr">8:  </span>    (tri 0 n)))
</pre>

<p>
这就是快速cl代码的典范，一开始就用这样写程序可能会觉得不太自然。更好的办法是先用自己最习惯的方式编写函数，然后在必要时把它转化成尾递归的等价形式。
</p></div>

</div>

<div id="outline-container-2-9" class="outline-3">
<h3 id="sec-2-9"><span class="section-number-3">2.9</span> 编译</h3>
<div class="outline-text-3" id="text-2-9">

<p>这节现在有很多不懂的，之后要返回来再看
</p></div>

</div>

<div id="outline-container-2-10" class="outline-3">
<h3 id="sec-2-10"><span class="section-number-3">2.10</span> 来自列表的函数</h3>
<div class="outline-text-3" id="text-2-10">


</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 函数式编程</h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 函数式设计</h3>
<div class="outline-text-3" id="text-3-1">

<p>函数式编程意味着利用返回值而不是副作用来写程序。副作用包括破坏性修改对象以及变量赋值。如果副作用很少并且局部化，程序就会容易阅读，测试和调试。
</p>
</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 内外颠倒的命令式</h3>
<div class="outline-text-3" id="text-3-2">

<p>函数式程序代码的用意相比命令式程序可能显得更加明确一些，函数式程序告诉你它想要什么;而命令式程序告诉你它要做什么。
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">&#20989;&#25968;&#24335;&#31243;&#24207;&#35828;&#8220;&#36820;&#22238;&#19968;&#20010;&#30001;a&#21644;x&#30340;&#31532;&#19968;&#20010;&#20803;&#32032;&#30340;&#24179;&#26041;&#25152;&#32452;&#25104;&#30340;&#21015;&#34920;&#8221;</span>
<span class="linenr">2:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">fun</span> (x)
<span class="linenr">3:  </span>  (list 'a (expt (car x) 2)))
<span class="linenr">4:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">&#21629;&#20196;&#24335;&#31243;&#24207;&#20250;&#35828;&#8220;&#21462;&#24471;x&#30340;&#31532;&#19968;&#20010;&#20803;&#32032;&#65292;&#25226;&#23427;&#24179;&#26041;&#65292;&#28982;&#21518;&#36820;&#22238;&#30001;a&#21450;&#20854;&#24179;&#26041;&#32452;&#25104;&#30340;&#21015;&#34920;&#8221;</span>
<span class="linenr">5:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">imp</span> (x)
<span class="linenr">6:  </span>  (<span style="color: #a020f0;">let</span> (y sqr)
<span class="linenr">7:  </span>    (setf y (car x))
<span class="linenr">8:  </span>    (setf sqr (expt y 2))
<span class="linenr">9:  </span>    (list 'a sqr)))
</pre>

<p>
不过这个是否可以理解为，函数式只是把命令式的代码写成一行，以以前的思想，第一种写法应该是不清晰的，就是把代码都写在一行，不好理解。这里说法正相反。以后有了更多的编码经验再回看这里吧，是否只是对lisp来说更加清晰呢，如果对Java来说用函数式编程会什么样子，以下为Java伪代码：
</p><pre class="example">
return (new ArrayList()).add('a').add(square(x.get(0)));
</pre>

<p>函数式编程和Lisp在一起让你写出更优雅的程序，事半功倍。
</p>
</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 函数式接口</h3>
<div class="outline-text-3" id="text-3-3">




<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">anything</span> (x)
<span class="linenr">2:  </span>  (+ x *anything*))
</pre>

<p>
虽然上边函数没有副作用，但它的返回值依赖于全局变量*anything*，因此，如果任何其他函数可以改变这个变量的值，那么anything就可能返回任意值。
要是把代码写成让每次调用都只修改它自己拥有的东西的话，那这样的代码就基本上就可以和纯函数式代码媲美了。
</p>
<p>
函数式接口：如果用同一参数调用它两次，你应当会得到同样的结果。这是自底向上程序设计最重要的组成部分。
</p>
<p>
函数应当避免写那些返回包含引用对象的函数：
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">&#36820;&#22238;&#20540;&#21253;&#21547;&#19968;&#20010;&#24341;&#29992;&#21015;&#34920;</span>
<span class="linenr"> 2:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">exclaim</span> (expression)
<span class="linenr"> 3:  </span>  (append expression '(oh my)))
<span class="linenr"> 4:  </span>
<span class="linenr"> 5:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">&#37027;&#20040;&#20219;&#20309;&#21518;&#32493;&#30340;&#23545;&#36820;&#22238;&#20540;&#30340;&#30772;&#22351;&#24615;&#20462;&#25913;</span>
<span class="linenr"> 6:  </span>(exclaim '(lions and tigers and bears)) <span style="color: #b22222;">; </span><span style="color: #b22222;">(LIONS AND TIGERS AND BEARS OH MY)</span>
<span class="linenr"> 7:  </span>(nconc * '(goodness)) <span style="color: #b22222;">; </span><span style="color: #b22222;">(LIONS AND TIGERS AND BEARS OH MY GOODNESS)</span>
<span class="linenr"> 8:  </span>
<span class="linenr"> 9:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">&#23558;&#26367;&#25442;&#20989;&#25968;&#37324;&#30340;&#21015;&#34920;</span>
<span class="linenr">10:  </span>(exclaim '(test)) <span style="color: #b22222;">; </span><span style="color: #b22222;">(TEST OH MY GOODNESS)</span>
<span class="linenr">11:  </span>
<span class="linenr">12:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">&#20026;&#20102;&#36991;&#20813;exclaim&#30340;&#36825;&#20010;&#38382;&#39064;&#65292;&#24212;&#35813;&#20889;&#25104;&#65306;</span>
<span class="linenr">13:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">exclaim</span> (expression)
<span class="linenr">14:  </span>  (append expression (list 'oh 'my)))
</pre>

<p>
函数不应返回引用列表，但也有例外，即生成宏展开的函数。宏展开器可以安全地在它们的展开式里包含引用列表，只要这些展开式是直接送到编译器那里的。
</p>
</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 交互式编程</h3>
<div class="outline-text-3" id="text-3-4">

<p>有经验的Lisp程序员会尽量让它们的程序易于测试：
</p><ol>
<li>他们试图把副作用分离到个别函数里，以便程序中更多的部分可以写成纯函数式风格。
</li>
<li>如果一个函数必须产生副作用，他们至少会想出办法给它设计一个函数式的接口
</li>
<li>他们给每个函数赋予一个单一的，定义良好的功能。
</li>
</ol>

<p>如果你所编写的函数影响外面世界的唯一渠道是它的返回值，那么只要返回值是你期望的，你就完全可以信任返回它的代码。
</p>
<p>
在自底向上的设计是一个进化的过程。在这个过程中，你在写程序的同时也就是在构造一门语言。这一方法只有当你信赖底层代码时才可行。如果你真的想把这一层作为语言使用，你就必须假设，如同使用其他语言时那样，任何遇到的bug都是你程序里的bug，而不是语言本身。难道你的新抽象有能力承担这一重任，同时还能按照新的需求随机应变？没错，在Lisp里你可以两不误。当以函数式风格编写程序，并且进行增量测试时，你可以得到随心所欲的灵活性，加上人们认为只有仔细计划才能确保的可靠性。
</p>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 实用函数</h2>
<div class="outline-text-2" id="text-4">

<p>本章将讲用函数来扩展Lisp的技术。关于这些函数，重要的不是知道怎样写，而是要知道它们从何而来。编写Lisp扩展的难点并不在于代码怎么写，而在于决定写什么。
</p>
</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 实用工具的诞生</h3>
<div class="outline-text-3" id="text-4-1">

<p>在编写Lisp程序时，同时也在为Lisp增加那些可以让你程序更容易编写的新操作符。这些操作符被称为实用工具。
“实用工具”这一术语并无明确的定义。有那么一段代码，如果把它看成独立的程序，感觉小了点，要是把它作为特定程序的一部分的话，这段代码又太通用了，这时就可以称之为实用工具。举例来说，数据库不能称为实用工具，但是对列表进行单一操作的函数就可以。大多数实用工具和Lisp已有的函数和宏很相似。事实上，许多Common Lisp内置的操作符就源自实用工具。用于收集列表中所有满足条件元素的remove-if-not函数，在它成为CL的一部分以前，就被程序员们私下里各自定义了多年。
</p>
<p>
学习编写实用工具与其说是学习编写的技术，不如说是养成编写实用工具的习惯。必须培养出一种能看出程序中缺少何种操作符的洞察力。你必须能够在看到一个程序时说，“啊，其实你真正的意思是这个。”
</p>
<p>
举个例子，假设nicknames是这样一个函数，它接受一个名字，然后构造出一个列表，列表由这个名字的所有昵称组成。有了这个函数，我们怎样收集一个名字列表对应的所有昵称呢？Lisp的初学者可能会写出类似的函数：
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">all-nicknames</span> (names)
<span class="linenr">2:  </span>  (<span style="color: #a020f0;">if</span> (null names)
<span class="linenr">3:  </span>      nil
<span class="linenr">4:  </span>      (nconc (nicknames (car names))
<span class="linenr">5:  </span>             (all-nicknames (cdr names)))))
</pre>

<p>
而更有经验的Lisp程序员可能一看到这样的函数就会说“啊，其实你真正想要的是mapcan。”然后，不再被迫定义并调用一个新函数来找出一组人的所有昵称，现在只要一个表达式就够了：
</p>


<pre class="src src-lisp">(mapcan #'nicknames people)
</pre>

<p>
定义all-nicknames完全是在重复地发明轮子。它的问题还不只于此：它同时也葬送了一个机会：本可以用通用操作符来直接完成某件事，却使用了专用的函数来实现它。对这个例子来说，操作符mapcan是现成的。任何知道mapcan的人在看到all-nicknames时都会觉得有点不太舒服。要想在自底向上程序设计方面做得好，就要在缺少的操作符还没有写出来的时候，同样觉得不舒服。
</p>
<p>
Lisp编程的要求之一，就是一旦有需要，就应该构思出新的实用工具。本章就是揭示这些工具是如何从无到有的。
</p>
</div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> 投资抽象</h3>
<div class="outline-text-3" id="text-4-2">

<p>简洁和效率同是优秀软件的本质特征。编写和维护一个程序的开销与其长度成正比。同等条件下，程序越短越好。从这一角度来看，编写实用工具可以被视为一种投资。实用工具可以放在单独的文件里;它们既不会在我们编写程序时分散我们的精力，也不会在事后我们修改遗留代码时被牵连进去。实用工具的质量必须过关。由于它们要被多次使用，所以任何不正确或者低效率之处都会成倍地偿还。一个新的实用工具必须为通用场合而作。
</p></div>

</div>

<div id="outline-container-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> 列表上的操作</h3>
<div class="outline-text-3" id="text-4-3">

<p>一个高度优化的CL程序里可能根本就没有列表的踪影。最专业的程序，在运行期很少使用列表，相反可能会在编译期生成宏展开式时大量使用列表。所以尽管列表的角色在现代Lisp方言里被淡化了，但是针对列表的各种操作仍然是Lisp程序的重要组成部分。
</p>

</div>

<div id="outline-container-4-3-1" class="outline-4">
<h4 id="sec-4-3-1"><span class="section-number-4">4.3.1</span> 列表实用工具</h4>
<div class="outline-text-4" id="text-4-3-1">

<p>一些list最小实用工具，为了满足效率的需要，应该把它们全部声明成inline。
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">proclaim</span> &#8217;(<span style="color: #a020f0;">inline</span> last1 single append1 conc1 mklist))
<span class="linenr"> 2:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#36820;&#22238;&#21015;&#34920;&#30340;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#65292;last&#36820;&#22238;&#26368;&#21518;&#19968;&#20010;cons</span>
<span class="linenr"> 3:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">last1</span> (lst)
<span class="linenr"> 4:  </span>  (car (last lst)))
<span class="linenr"> 5:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#21028;&#26029;&#26159;&#21542;&#20026;&#21333;&#20803;&#32032;&#30340;&#21015;&#34920;&#65292;(= (length lst) 1)&#36825;&#26679;&#20889;&#22826;&#20302;&#25928;</span>
<span class="linenr"> 6:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">single</span> (lst)
<span class="linenr"> 7:  </span>  (and (consp lst) (not (cdr lst))))
<span class="linenr"> 8:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#22312;&#21015;&#34920;&#32467;&#23614;&#36861;&#21152;&#19968;&#20010;&#26032;&#20803;&#32032;</span>
<span class="linenr"> 9:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">append1</span> (lst obj)
<span class="linenr">10:  </span>  (append lst (list obj)))
<span class="linenr">11:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#30772;&#22351;&#24615;&#29256;&#26412;</span>
<span class="linenr">12:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">conc1</span> (lst obj)
<span class="linenr">13:  </span>  (nconc lst (list obj)))
<span class="linenr">14:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#30830;&#20445;&#26576;&#20010;&#19996;&#35199;&#26159;&#21015;&#34920;</span>
<span class="linenr">15:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">mklist</span> (obj)
<span class="linenr">16:  </span>  (<span style="color: #a020f0;">if</span> (listp obj) obj (list obj)))
</pre>

<p>
一些较大的列表实用工具
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#27604;&#36739;&#20004;&#20010;&#21015;&#34920;&#65292;&#21069;&#19968;&#20010;&#21015;&#34920;&#26356;&#38271;&#30340;&#26102;&#20505;&#25165;&#36820;&#22238;&#30495;</span>
<span class="linenr"> 2:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">(&gt; (length x) (length y)) &#20302;&#25928;&#65292;&#23436;&#20840;&#36941;&#21382;&#20004;&#20010;&#34920;</span>
<span class="linenr"> 3:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">longer</span> (x y)
<span class="linenr"> 4:  </span>  (<span style="color: #a020f0;">labels</span> ((compare (x y)
<span class="linenr"> 5:  </span>             (and (consp x)
<span class="linenr"> 6:  </span>                  (or (null y)
<span class="linenr"> 7:  </span>                      (compare (cdr x) (cdr y))))))
<span class="linenr"> 8:  </span>    (<span style="color: #a020f0;">if</span> (and (listp x) (listp y))
<span class="linenr"> 9:  </span>        (compare x y)
<span class="linenr">10:  </span>        (&gt; (length x) (length y)))))
<span class="linenr">11:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#25226;&#19968;&#20010;&#20989;&#25968;&#20316;&#29992;&#22312;&#21015;&#34920;&#20803;&#32032;&#19978;&#36820;&#22238;&#30340;&#20540;&#19981;&#20026;&#31354;&#65292;&#23601;&#25226;&#36825;&#26679;&#30340;&#36820;&#22238;&#20540;&#25910;&#38598;&#36215;&#26469;&#65292;&#26500;&#25104;&#21015;&#34920;</span>
<span class="linenr">12:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">filter</span> (fn lst)
<span class="linenr">13:  </span>  (<span style="color: #a020f0;">let</span> ((acc nil))
<span class="linenr">14:  </span>    (<span style="color: #a020f0;">dolist</span> (x lst)
<span class="linenr">15:  </span>      (<span style="color: #a020f0;">let</span> ((val (funcall fn x)))
<span class="linenr">16:  </span>        (<span style="color: #a020f0;">if</span> val (push val acc))))
<span class="linenr">17:  </span>    (nreverse acc)))
<span class="linenr">18:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#36820;&#22238;&#19968;&#20010;&#30001;&#21407;&#21015;&#34920;&#20803;&#32032;&#25353;&#38271;&#24230;&#20026;n&#30340;&#23376;&#21015;&#34920;&#32452;&#25104;&#12290;</span>
<span class="linenr">19:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">(group '(1 2 3 4 5) 2) ==&gt; ((1 2) (3 4) 5)</span>
<span class="linenr">20:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">group</span> (source n)
<span class="linenr">21:  </span>  (<span style="color: #a020f0;">if</span> (zerop n) (<span style="color: #ff0000; font-weight: bold;">error</span> &#8221;zero length&#8221;))
<span class="linenr">22:  </span>  (<span style="color: #a020f0;">labels</span> ((rec (source acc)
<span class="linenr">23:  </span>             (<span style="color: #a020f0;">let</span> ((rest (nthcdr n source)))
<span class="linenr">24:  </span>               (<span style="color: #a020f0;">if</span> (consp rest)
<span class="linenr">25:  </span>                   (rec rest (cons (subseq source 0 n) acc))
<span class="linenr">26:  </span>                   (nreverse (cons source acc))))))
<span class="linenr">27:  </span>    (<span style="color: #a020f0;">if</span> source (rec source nil) nil)))
</pre>

<pre class="example">
(group '(a b c d e f g) 2) ==&gt; ((A B) (C D) (E F) (G))
</pre>

<p>使用双递归的列表实用工具
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#36820;&#22238;&#30001;&#21015;&#34920;&#20013;&#30340;&#25152;&#26377;&#21407;&#23376;&#65288;atom&#65289;&#25152;&#32452;&#25104;&#30340;&#21015;&#34920;</span>
<span class="linenr"> 2:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">flatten</span> (x)
<span class="linenr"> 3:  </span>  (<span style="color: #a020f0;">labels</span> ((rec (x acc)
<span class="linenr"> 4:  </span>             (<span style="color: #a020f0;">cond</span> ((null x) acc)
<span class="linenr"> 5:  </span>                   ((atom x) (cons x acc))
<span class="linenr"> 6:  </span>                   (t (rec (car x) (rec (cdr x) acc))))))
<span class="linenr"> 7:  </span>    (rec x nil)))
<span class="linenr"> 8:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#23427;&#23545;remove-if&#30340;&#24847;&#20041;&#23601;&#30456;&#24403;&#20110;copy-tree&#20043;&#20110;copy-list</span>
<span class="linenr"> 9:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">(prune #&#8217;evenp &#8217;(1 2 (3 (4 5) 6) 7 8 (9))) == &gt;(1 (3 (5)) 7 (9))</span>
<span class="linenr">10:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">prune</span> (test tree)
<span class="linenr">11:  </span>  (<span style="color: #a020f0;">labels</span> ((rec (tree acc)
<span class="linenr">12:  </span>             (<span style="color: #a020f0;">cond</span> ((null tree) (nreverse acc))
<span class="linenr">13:  </span>                   ((consp (car tree))
<span class="linenr">14:  </span>                    (rec (cdr tree)
<span class="linenr">15:  </span>                         (cons (rec (car tree) nil) acc)))
<span class="linenr">16:  </span>                   (t (rec (cdr tree)
<span class="linenr">17:  </span>                           (<span style="color: #a020f0;">if</span> (funcall test (car tree))
<span class="linenr">18:  </span>                               acc
<span class="linenr">19:  </span>                               (cons (car tree) acc)))))))
<span class="linenr">20:  </span>    (rec tree nil)))
</pre>

</div>
</div>

</div>

<div id="outline-container-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> 搜索</h3>
<div class="outline-text-3" id="text-4-4">

<p>搜索列表函数
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#26597;&#25214;&#25226;fn&#24212;&#29992;&#20110;lst&#20013;&#20803;&#32032;&#31532;&#19968;&#20010;&#36820;&#22238;&#20540;&#19981;&#20026;&#31354;&#30340;&#65292;&#36820;&#22238;&#27492;&#20803;&#32032;&#21644;fn&#36820;&#22238;&#20540;</span>
<span class="linenr"> 2:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find2</span> (fn lst)
<span class="linenr"> 3:  </span>  (<span style="color: #a020f0;">if</span> (null lst)
<span class="linenr"> 4:  </span>      nil
<span class="linenr"> 5:  </span>      (<span style="color: #a020f0;">let</span> ((val (funcall fn (car lst))))
<span class="linenr"> 6:  </span>        (<span style="color: #a020f0;">if</span> val
<span class="linenr"> 7:  </span>            (values (car lst) val)
<span class="linenr"> 8:  </span>            (find2 fn (cdr lst))))))
<span class="linenr"> 9:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#22312;lst&#20013;&#19968;&#20010;&#23545;&#35937;x&#26159;&#21542;&#22312;&#21478;&#19968;&#20010;&#23545;&#35937;y&#21069;&#38754;</span>
<span class="linenr">10:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">before</span> (x y lst <span style="color: #228b22;">&amp;key</span> (test #&#8217;eql))
<span class="linenr">11:  </span>  (and lst
<span class="linenr">12:  </span>       (<span style="color: #a020f0;">let</span> ((first (car lst)))
<span class="linenr">13:  </span>         (<span style="color: #a020f0;">cond</span> ((funcall test y first) nil)
<span class="linenr">14:  </span>               ((funcall test x first) lst)
<span class="linenr">15:  </span>               (t (before x y (cdr lst) <span style="color: #483d8b;">:test</span> test))))))
<span class="linenr">16:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#19982;&#19978;&#38754;&#30456;&#21453;&#65292;&#27604;before&#26356;&#20026;&#32454;&#33268;&#30340;&#27979;&#35797;&#65292;&#35201;&#27714;&#20004;&#20010;&#21442;&#25968;&#37117;&#20986;&#29616;&#22312;&#21015;&#34920;&#37324;</span>
<span class="linenr">17:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">after</span> (x y lst <span style="color: #228b22;">&amp;key</span> (test #&#8217;eql))
<span class="linenr">18:  </span>  (<span style="color: #a020f0;">let</span> ((rest (before y x lst <span style="color: #483d8b;">:test</span> test)))
<span class="linenr">19:  </span>    (and rest (member x rest <span style="color: #483d8b;">:test</span> test))))
<span class="linenr">20:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#21028;&#26029;obj&#22312;lst&#20013;&#26159;&#21542;&#37325;&#22797;&#20986;&#29616;</span>
<span class="linenr">21:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">duplicate</span> (obj lst <span style="color: #228b22;">&amp;key</span> (test #&#8217;eql))
<span class="linenr">22:  </span>  (member obj (cdr (member obj lst <span style="color: #483d8b;">:test</span> test))
<span class="linenr">23:  </span>          <span style="color: #483d8b;">:test</span> test))
<span class="linenr">24:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#36820;&#22238;&#20197;&#25226;&#20989;&#25968;fn&#24212;&#29992;&#22312;&#21015;&#34920;lst&#20803;&#32032;&#36820;&#22238;&#19981;&#20026;nil&#30340;&#20803;&#32032;&#20026;&#20998;&#21106;&#30340;&#20004;&#20010;&#21015;&#34920;</span>
<span class="linenr">25:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#20027;&#35201;&#29992;&#20110;&#24050;&#32463;&#25353;&#29031;&#26576;&#31181;&#35268;&#21017;&#25490;&#22909;&#24207;&#30340;&#21015;&#34920;</span>
<span class="linenr">26:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">split-if</span> (fn lst)
<span class="linenr">27:  </span>  (<span style="color: #a020f0;">let</span> ((acc nil))
<span class="linenr">28:  </span>    (<span style="color: #a020f0;">do</span> ((src lst (cdr src)))
<span class="linenr">29:  </span>        ((or (null src) (funcall fn (car src)))
<span class="linenr">30:  </span>         (values (nreverse acc) src))
<span class="linenr">31:  </span>      (push (car src) acc))))
</pre>

<p>
带有列表元素比较的搜索函数
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#25509;&#21463;&#19968;&#20010;&#21015;&#34920;&#21644;&#19968;&#20010;&#29992;&#26469;&#25171;&#20998;&#30340;&#20989;&#25968;&#65292;&#36820;&#22238;&#20998;&#25968;&#26368;&#39640;&#30340;&#20803;&#32032;</span>
<span class="linenr"> 2:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">most</span> (fn lst)
<span class="linenr"> 3:  </span>  (<span style="color: #a020f0;">if</span> (null lst)
<span class="linenr"> 4:  </span>      (values nil nil)
<span class="linenr"> 5:  </span>      (<span style="color: #a020f0;">let*</span> ((wins (car lst))
<span class="linenr"> 6:  </span>             (max (funcall fn wins)))
<span class="linenr"> 7:  </span>        (<span style="color: #a020f0;">dolist</span> (obj (cdr lst))
<span class="linenr"> 8:  </span>          (<span style="color: #a020f0;">let</span> ((score (funcall fn obj)))
<span class="linenr"> 9:  </span>            (<span style="color: #a020f0;">when</span> (&gt; score max)
<span class="linenr">10:  </span>              (setq wins obj
<span class="linenr">11:  </span>                    max score))))
<span class="linenr">12:  </span>        (values wins max))))
<span class="linenr">13:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#29992;&#19968;&#20010;&#25509;&#21463;&#20004;&#20010;&#21442;&#25968;&#30340;&#35859;&#35789;&#20989;&#25968;&#27604;&#36739;&#21015;&#34920;&#20013;&#20803;&#32032;&#65292;&#36820;&#22238;&#22312;&#35813;&#35859;&#35789;&#19979;&#32988;&#20986;&#30340;&#20803;&#32032;</span>
<span class="linenr">14:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">best</span> (fn lst)
<span class="linenr">15:  </span>  (<span style="color: #a020f0;">if</span> (null lst)
<span class="linenr">16:  </span>      nil
<span class="linenr">17:  </span>      (<span style="color: #a020f0;">let</span> ((wins (car lst)))
<span class="linenr">18:  </span>        (<span style="color: #a020f0;">dolist</span> (obj (cdr lst))
<span class="linenr">19:  </span>          (<span style="color: #a020f0;">if</span> (funcall fn obj wins)
<span class="linenr">20:  </span>              (setq wins obj)))
<span class="linenr">21:  </span>        wins)))
<span class="linenr">22:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#19982;most&#31867;&#20284;&#65292;&#36820;&#22238;&#19968;&#20010;&#30001;&#33719;&#24471;&#26368;&#39640;&#20998;&#30340;&#25152;&#26377;&#20803;&#32032;&#21644;&#26368;&#39640;&#20998;&#32452;&#25104;&#30340;&#21015;&#34920;</span>
<span class="linenr">23:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">mostn</span> (fn lst)
<span class="linenr">24:  </span>  (<span style="color: #a020f0;">if</span> (null lst)
<span class="linenr">25:  </span>      (values nil nil)
<span class="linenr">26:  </span>      (<span style="color: #a020f0;">let</span> ((result (list (car lst)))
<span class="linenr">27:  </span>            (max (funcall fn (car lst))))
<span class="linenr">28:  </span>        (<span style="color: #a020f0;">dolist</span> (obj (cdr lst))
<span class="linenr">29:  </span>          (<span style="color: #a020f0;">let</span> ((score (funcall fn obj)))
<span class="linenr">30:  </span>            (<span style="color: #a020f0;">cond</span> ((&gt; score max)
<span class="linenr">31:  </span>                   (setq max score
<span class="linenr">32:  </span>                         result (list obj)))
<span class="linenr">33:  </span>                  ((= score max)
<span class="linenr">34:  </span>                   (push obj result)))))
<span class="linenr">35:  </span>        (values (nreverse result) max))))
</pre>

</div>

</div>

<div id="outline-container-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> 映射</h3>
<div class="outline-text-3" id="text-4-5">

<p>映射函数
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">(map0-n #&#8217;1+ 5) ==&gt; (1 2 3 4 5 6)</span>
<span class="linenr"> 2:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">map0-n</span> (fn n)
<span class="linenr"> 3:  </span>  (mapa-b fn 0 n))
<span class="linenr"> 4:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">(map1-n #&#8217;1+ 5) ==&gt; (2 3 4 5 6)</span>
<span class="linenr"> 5:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">map1-n</span> (fn n)
<span class="linenr"> 6:  </span>  (mapa-b fn 1 n))
<span class="linenr"> 7:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">(mapa-b #&#8217;1+ -2 0 .5) ==&gt; (-1 -0.5 0.0 0.5 1.0)</span>
<span class="linenr"> 8:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">mapa-b</span> (fn a b <span style="color: #228b22;">&amp;optional</span> (step 1))
<span class="linenr"> 9:  </span>  (<span style="color: #a020f0;">do</span> ((i a (+ i step))
<span class="linenr">10:  </span>       (result nil))
<span class="linenr">11:  </span>      ((&gt; i b) (nreverse result))
<span class="linenr">12:  </span>    (push (funcall fn i) result)))
<span class="linenr">13:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#27604;mapa-b&#26356;&#21152;&#36890;&#29992;&#65292;&#20511;&#21161;map-&gt;&#19981;&#20165;&#33021;&#36941;&#21382;&#25972;&#25968;&#24207;&#21015;&#65292;&#36824;&#21487;&#20197;&#36941;&#21382;&#20219;&#20309;&#19968;&#31181;&#25968;&#25454;&#32467;&#26500;</span>
<span class="linenr">14:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">map-&gt;&#25105;&#27809;&#22826;&#30475;&#26126;&#30333;&#20160;&#20040;&#22320;&#26041;&#29992;...</span>
<span class="linenr">15:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">map-&gt;</span> (fn start test-fn succ-fn)
<span class="linenr">16:  </span>  (<span style="color: #a020f0;">do</span> ((i start (funcall succ-fn i))
<span class="linenr">17:  </span>       (result nil))
<span class="linenr">18:  </span>      ((funcall test-fn i) (nreverse result))
<span class="linenr">19:  </span>    (push (funcall fn i) result)))
<span class="linenr">20:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">mapa-b&#21487;&#20197;&#29992;map-&gt;&#23450;&#20041;</span>
<span class="linenr">21:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">mapa-b</span> (fn a b <span style="color: #228b22;">&amp;optional</span> (step 1))
<span class="linenr">22:  </span>  (map-&gt; fn
<span class="linenr">23:  </span>         a
<span class="linenr">24:  </span>         #&#8217;(<span style="color: #a020f0;">lambda</span> (x) (&gt; x b))
<span class="linenr">25:  </span>         #&#8217;(<span style="color: #a020f0;">lambda</span> (x) (+ x step))))
<span class="linenr">26:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">mapcan&#30340;&#38750;&#30772;&#22351;&#24615;&#29256;&#26412;</span>
<span class="linenr">27:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">mappend</span> (fn <span style="color: #228b22;">&amp;rest</span> lsts)
<span class="linenr">28:  </span>  (apply #&#8217;append (apply #&#8217;mapcar fn lsts)))
<span class="linenr">29:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">mapcan&#20063;&#21487;&#29992;&#19979;&#21015;&#20195;&#30721;&#34920;&#36798;</span>
<span class="linenr">30:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">our-mapcan</span> (fn <span style="color: #228b22;">&amp;rest</span> lsts)
<span class="linenr">31:  </span>  (apply #&#8217;nconc (apply #&#8217;mapcar fn lsts)))
<span class="linenr">32:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#23545;&#22810;&#20010;&#21015;&#34920; mapcar &#26576;&#20010;&#20989;&#25968;</span>
<span class="linenr">33:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">mapcars</span> (fn <span style="color: #228b22;">&amp;rest</span> lsts)
<span class="linenr">34:  </span>  (<span style="color: #a020f0;">let</span> ((result nil))
<span class="linenr">35:  </span>    (<span style="color: #a020f0;">dolist</span> (lst lsts)
<span class="linenr">36:  </span>      (<span style="color: #a020f0;">dolist</span> (obj lst)
<span class="linenr">37:  </span>        (push (funcall fn obj) result)))
<span class="linenr">38:  </span>    (nreverse result)))
<span class="linenr">39:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#36866;&#29992;&#20110;&#26641;&#30340; mapcar &#29256;&#26412;&#12290;&#23427;&#30340;&#21517;&#23383; rmapcar &#26159; &#8220;recursive mapcar &#8221; &#30340;&#32553;&#20889;</span>
<span class="linenr">40:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">rmapcar</span> (fn <span style="color: #228b22;">&amp;rest</span> args)
<span class="linenr">41:  </span>  (<span style="color: #a020f0;">if</span> (some #&#8217;atom args)
<span class="linenr">42:  </span>      (apply fn args)
<span class="linenr">43:  </span>      (apply #&#8217;mapcar
<span class="linenr">44:  </span>                #&#8217;(<span style="color: #a020f0;">lambda</span> (<span style="color: #228b22;">&amp;rest</span> args)
<span class="linenr">45:  </span>                     (apply #&#8217;rmapcar fn args))
<span class="linenr">46:  </span>                   args)))
</pre>


</div>

</div>

<div id="outline-container-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> I/O</h3>
<div class="outline-text-3" id="text-4-6">

<p>I/O函数
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#35835;&#20837;&#19968;&#34892;&#24182;&#20197;&#21015;&#34920;&#24418;&#24335;&#36820;&#22238;&#65292;&#35843;&#29992;values&#26159;&#20026;&#20102;&#21482;&#24471;&#21040;&#19968;&#20010;&#36820;&#22238;&#20540;</span>
<span class="linenr"> 2:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&gt; (readlist)</span>
<span class="linenr"> 3:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">Call me &#8221;Ed&#8221;</span>
<span class="linenr"> 4:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">(CALL ME &#8221;Ed&#8221;)</span>
<span class="linenr"> 5:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">readlist</span> (<span style="color: #228b22;">&amp;rest</span> args)
<span class="linenr"> 6:  </span>  (values (read-from-string
<span class="linenr"> 7:  </span>           (concatenate &#8217;string &#8221;(&#8221;
<span class="linenr"> 8:  </span>                                (apply #&#8217;read-line args)
<span class="linenr"> 9:  </span>                                &#8221;)&#8221;))))
<span class="linenr">10:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#20989;&#25968; prompt &#25226;&#25171;&#21360;&#38382;&#39064;&#21644;&#35835;&#21462;&#31572;&#26696;&#32467;&#21512;&#20102;&#36215;&#26469;</span>
<span class="linenr">11:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&gt; (prompt &#8221;Enter a number between ~A and ~A.~%&gt;&gt; &#8221; 1 10)</span>
<span class="linenr">12:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">Enter a number between 1 and 10.</span>
<span class="linenr">13:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&gt;&gt; 3</span>
<span class="linenr">14:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">3</span>
<span class="linenr">15:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">prompt</span> (<span style="color: #228b22;">&amp;rest</span> args)
<span class="linenr">16:  </span>  (apply #&#8217;format *query-io* args)
<span class="linenr">17:  </span>  (read *query-io*))
<span class="linenr">18:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#25509;&#21463;&#20004;&#20010;&#20989;&#25968;&#21644;&#19968;&#20010; &amp;rest &#21442;&#25968;,&#21518;&#32773;&#19968;&#27425;&#21448;&#19968;&#27425;&#22320;&#20316;&#20026;&#21442;&#25968;&#20256;&#32473; prompt</span>
<span class="linenr">19:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">break-loop</span> (fn quit <span style="color: #228b22;">&amp;rest</span> args)
<span class="linenr">20:  </span>  (format *query-io* &#8221;Entering break-loop.&#8217;~%&#8221;)
<span class="linenr">21:  </span>  (<span style="color: #a020f0;">loop</span>
<span class="linenr">22:  </span>     (<span style="color: #a020f0;">let</span> ((in (apply #&#8217;prompt args)))
<span class="linenr">23:  </span>       (<span style="color: #a020f0;">if</span> (funcall quit in)
<span class="linenr">24:  </span>           (<span style="color: #a020f0;">return</span>)
<span class="linenr">25:  </span>           (format *query-io* &#8221;~A~%&#8221; (funcall fn in))))))
<span class="linenr">26:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#21487;&#20197;&#20687;&#36825;&#26679;&#26469;&#27169;&#20223;&#30495;&#27491;&#30340; Lisp toplevel &#29615;&#22659;</span>
<span class="linenr">27:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&gt; (break-loop #&#8217;eval #&#8217;(lambda (x) (eq x :q)) &#8221;&gt;&gt; &#8221;)</span>
<span class="linenr">28:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">Enter break-loop.</span>
<span class="linenr">29:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&gt;&gt; (+ 2 3)</span>
<span class="linenr">30:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">5</span>
<span class="linenr">31:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&gt;&gt; :q</span>
<span class="linenr">32:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">:Q</span>
</pre>


</div>

</div>

<div id="outline-container-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> 符号和字符串</h3>
<div class="outline-text-3" id="text-4-7">

<p>操作符号和字符串的函数
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#25509;&#21463;&#20219;&#24847;&#25968;&#37327;&#30340;&#21442;&#25968;,&#24182;&#23558;&#23427;&#20204;&#30340;&#25171;&#21360;&#24418;&#24335;&#36830;&#36215;&#26469;,&#24418;&#25104;&#19968;&#20010;&#23383;&#31526;&#20018;</span>
<span class="linenr"> 2:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">mkstr</span> (<span style="color: #228b22;">&amp;rest</span> args)
<span class="linenr"> 3:  </span>  (<span style="color: #a020f0;">with-output-to-string</span> (s)
<span class="linenr"> 4:  </span>    (<span style="color: #a020f0;">dolist</span> (a args) (princ a s))))
<span class="linenr"> 5:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#26500;&#36896;&#31526;&#21495;&#12290;&#23427;&#25509;&#21463;&#19968;&#20010;&#25110;&#22810;&#20010;&#21442;&#25968;,&#24182;&#36820;&#22238;&#19968;&#20010;&#31526;&#21495; ( &#33509;&#38656;&#35201;&#30340;&#35805;,&#21017;&#20250;&#26032;&#24314;&#19968;&#20010; ) ,&#20351;&#20854;&#25171;&#21360;&#21517;&#31216;&#31561;&#20110;&#25152;&#26377;&#21442;&#25968;&#36830;&#25509;&#22312;&#19968;&#36215;&#30340;&#23383;&#31526;&#20018;</span>
<span class="linenr"> 6:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&gt; (symb &#8217;ar &#8221;Madi&#8221; #\L #\L 0) ==&gt; |ARMadiLL0|</span>
<span class="linenr"> 7:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">symb</span> (<span style="color: #228b22;">&amp;rest</span> args)
<span class="linenr"> 8:  </span>  (values (intern (apply #&#8217;mkstr args))))
<span class="linenr"> 9:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#26159;symb&#30340;&#36890;&#29992;&#21270;&#29256;&#26412;&#65292;&#27809;&#22826;&#29702;&#35299;&#27492;&#20989;&#25968;&#65292;&#23545;&#31526;&#21495;&#29702;&#35299;&#19981;&#28145;...</span>
<span class="linenr">10:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">reread</span> (<span style="color: #228b22;">&amp;rest</span> args)
<span class="linenr">11:  </span>  (values (read-from-string (apply #&#8217;mkstr args))))
<span class="linenr">12:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#36820;&#22238;&#31526;&#21495;&#21517;&#31216;&#37324;&#30340;&#23383;&#31526;&#25152;&#32452;&#25104;&#30340;&#21015;&#34920;</span>
<span class="linenr">13:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&gt; (explode &#8217;bomb) ==&gt; (B O M B)</span>
<span class="linenr">14:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">explode</span> (sym)
<span class="linenr">15:  </span>  (map &#8217;list #&#8217;(<span style="color: #a020f0;">lambda</span> (c)
<span class="linenr">16:  </span>                   (intern (make-string 1
<span class="linenr">17:  </span>                                        <span style="color: #483d8b;">:initial-element</span> c)))
<span class="linenr">18:  </span>         (symbol-name sym)))
</pre>


</div>

</div>

<div id="outline-container-4-8" class="outline-3">
<h3 id="sec-4-8"><span class="section-number-3">4.8</span> 紧凑性</h3>
<div class="outline-text-3" id="text-4-8">

<p>人们抱怨说使用实用工具使得你的代码难于阅读了,他们很可能根本没有意识到,如果你不
使用这些实用工具的话代码看起来将是什么样子。自底向上程序设计让本来规模很大的程序看起来短小简单。给人的感觉就是,这程序并没有做很多事,所以应该很好懂。当缺乏经验的读者们更仔细地阅读程序,结果发现事情并没有想象的那么简单,他们就会灰心丧气。
自底向上的程序有种感官上的紧密性。阅读这种程序可能需要花一些力气,但如果不是这样写的话,你会需要花更多的精力来读懂它们。
</p>
<p>
有一种情况下,你应该有意地避免使用实用工具,即 : 如果你需要写一个小程序,它将独立于其余部分的代码发布。一个实用工具通常至少要被使用两到三次才值得引入,但在小程序里 , 如果一个实用工具用得太少的话,可能就没有必要包含它了。
</p>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 函数作为返回值</h2>
<div class="outline-text-2" id="text-5">



</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Common Lisp 的演化</h3>
<div class="outline-text-3" id="text-5-1">

<p>Common Lisp 最初提供了几组互补的函数。 remove-if 和 remove-if-not 就是这样的一对，
</p>
<p>
(remove-if-not #’pred lst) == (remove-if #’(lambda (x) (not (pred x))) lst)
</p>
<p>
Cltl2里提供了一个新的函数，complemen需要一个谓词 p 作为参数,它返回一个函数,这个函数的返回值总是和谓词得到的返回值相反。
</p>
<p>
(remove-if-not #’pred lst) == (remove-if (complement #’pred) lst)
</p>
<p>
有了 complement ,就没有什么理由再用那些 -if-not 函数了。
</p>
<p>
如果想一想 complement 是怎么写的,也可以推知它返回的必定也是一个闭包 :
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">complement</span> (fn)
<span class="linenr">2:  </span>  #&#8217;(<span style="color: #a020f0;">lambda</span> (<span style="color: #228b22;">&amp;rest</span> args) (not (apply fn args))))
</pre>

<p>
在进行抽象时,把函数作为参数的能力不啻为一个强有力的工具。而能够编写返回函数的函数,让我们可以把这个能力发挥到极致。
</p>
</div>

</div>

<div id="outline-container-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 正交性</h3>
<div class="outline-text-3" id="text-5-2">

<p>正交 的语言让我们只需运用多种方式对数量有限的操作符加以组合,就能获得强大的表达能力。
</p>
<p>
在 complement 出现之前, Common Lisp 曾有成对的函数,如 remove-if 和 remove-if-not 、 subst-if 和 subst-if-not ,等等。自从有了 complement ,我们可以只用一半数量的函数就完成全部的功能。同样, setf 宏也增强了 Lisp 的正交性。 Lisp 的早期方言常会用成对的函数分别实现读数据和写数据的功能。举例来说,对于属性列表 (property-list) ,就用一个函数设置属性,而用另一个函数来查询属性。在 Common Lisp 里面,我们只有后者,即 get 。为了加入一个属性,我们把 get 和 setf 一同使用 :(setf (get ’ball ’color) ’red)
</p>
</div>

</div>

<div id="outline-container-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> 记住过去</h3>
<div class="outline-text-3" id="text-5-3">

<p>如果某些函数的计算量非常大,而且我们有时会对它们执行相同的调用,这时 “ 记住过去 ” 就有用了 : 就是让函数把所有以往调用的返回值都缓存下来 , 以后每次调用时,都先在缓存里找一下,看看返回值是不是以前算过。
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#36825;&#20989;&#25968;&#29275;B&#21834;&#65292;&#36825;&#19981;&#23601;&#26159;&#22312;SICP&#37324;&#26641;&#24418;&#36882;&#24402;&#26102;&#35828;&#30340;&#20248;&#21270;&#26041;&#27861;&#30340;&#23454;&#29616;&#22043;&#65281;&#21704;&#21704;</span>
<span class="linenr"> 2:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#25105;&#20204;&#20256;&#32473; memoize &#19968;&#20010;&#20989;&#25968;,&#23427;&#23601;&#33021;&#36820;&#22238;&#23545;&#24212;&#30340;&#26377;&#35760;&#24518;&#30340;&#29256;&#26412;&#21363;&#19968;&#20010;&#38381;&#21253;,&#35813;&#38381;&#21253;&#21547;&#26377;&#23384;&#20648;&#20197;&#24448;&#35843;&#29992;&#32467;&#26524;&#30340;&#21704;&#24076;&#34920;&#12290;</span>
<span class="linenr"> 3:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">memoize</span> (fn)
<span class="linenr"> 4:  </span>  (<span style="color: #a020f0;">let</span> ((cache (make-hash-table <span style="color: #483d8b;">:test</span> #&#8217;equal)))
<span class="linenr"> 5:  </span>    #&#8217;(<span style="color: #a020f0;">lambda</span> (<span style="color: #228b22;">&amp;rest</span> args)
<span class="linenr"> 6:  </span>         (<span style="color: #a020f0;">multiple-value-bind</span> (val win) (gethash args cache)
<span class="linenr"> 7:  </span>           (<span style="color: #a020f0;">if</span> win
<span class="linenr"> 8:  </span>               val
<span class="linenr"> 9:  </span>               (setf (gethash args cache)
<span class="linenr">10:  </span>                     (apply fn args)))))))
</pre>


</div>

</div>

<div id="outline-container-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> 复合函数</h3>
<div class="outline-text-3" id="text-5-4">

<p>常见的函数操作是复合,它被记作 ◦ 。如果 f 和 g 是两个函数,那么 f ◦ g 也是函数,并且 f ◦ g(x) = f (g(x)) 。通过使用闭包的方式,也可以把 ◦ 定义为一个 Lisp 函数。
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#25152;&#26377;&#20256;&#32473; compose &#20316;&#20026;&#21442;&#25968;&#30340;&#20989;&#25968;&#37117;&#24517;&#39035;&#21482;&#25509;&#21463;&#19968;&#20010;&#21442;&#25968;,&#19981;&#36807;&#26368;&#21518;&#19968;&#20010;&#20989;&#25968;&#21442;&#25968;&#21487;&#20197;&#20363;&#22806;</span>
<span class="linenr"> 2:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">compose</span> (<span style="color: #228b22;">&amp;rest</span> fns)
<span class="linenr"> 3:  </span>  (<span style="color: #a020f0;">if</span> fns
<span class="linenr"> 4:  </span>      (<span style="color: #a020f0;">let</span> ((fn1 (car (last fns)))
<span class="linenr"> 5:  </span>            (fns (butlast fns)))
<span class="linenr"> 6:  </span>        #&#8217;(<span style="color: #a020f0;">lambda</span> (<span style="color: #228b22;">&amp;rest</span> args)
<span class="linenr"> 7:  </span>             (reduce #&#8217;funcall fns
<span class="linenr"> 8:  </span>                        <span style="color: #483d8b;">:from-end</span> t
<span class="linenr"> 9:  </span>                        <span style="color: #483d8b;">:initial-value</span> (apply fn1 args))))
<span class="linenr">10:  </span>      #&#8217;identity))
<span class="linenr">11:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">(mapcar #&#8217;(lambda (x)</span>
<span class="linenr">12:  </span><span style="color: #b22222;">;;           </span><span style="color: #b22222;">(if (slave x)</span>
<span class="linenr">13:  </span><span style="color: #b22222;">;;               </span><span style="color: #b22222;">(owner x)</span>
<span class="linenr">14:  </span><span style="color: #b22222;">;;               </span><span style="color: #b22222;">(employer x)))</span>
<span class="linenr">15:  </span><span style="color: #b22222;">;;         </span><span style="color: #b22222;">people)</span>
<span class="linenr">16:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#20063;&#21487;&#20197;&#23450;&#20041;&#25805;&#20316;&#31526;</span>
<span class="linenr">17:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">(mapcar (fif #&#8217;slave #&#8217;owner #&#8217;employer)</span>
<span class="linenr">18:  </span><span style="color: #b22222;">;;         </span><span style="color: #b22222;">people)</span>
<span class="linenr">19:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">fif</span> (<span style="color: #a020f0;">if</span> then <span style="color: #228b22;">&amp;optional</span> else)
<span class="linenr">20:  </span>  #&#8217;(<span style="color: #a020f0;">lambda</span> (x)
<span class="linenr">21:  </span>       (<span style="color: #a020f0;">if</span> (funcall if x)
<span class="linenr">22:  </span>           (funcall then x)
<span class="linenr">23:  </span>           (<span style="color: #a020f0;">if</span> else (funcall else x)))))
<span class="linenr">24:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">(find-if #&#8217;(lambda (x)</span>
<span class="linenr">25:  </span><span style="color: #b22222;">;;            </span><span style="color: #b22222;">(and (signed x) (sealed x) (delivered x)))</span>
<span class="linenr">26:  </span><span style="color: #b22222;">;;          </span><span style="color: #b22222;">docs)</span>
<span class="linenr">27:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#20316;&#20026;&#31532;&#20108;&#20010;&#21442;&#25968;&#20256;&#32473; find-if &#30340;&#35859;&#35789;&#20989;&#25968;&#23450;&#20041;&#20102;&#19968;&#20010;&#30001;&#19977;&#20010;&#35859;&#35789;&#30830;&#23450;&#30340;&#20132;&#38598;,&#36825;&#19977;&#20010;&#35859;&#35789;&#23558;&#20250;&#22312;&#36825;</span>
<span class="linenr">28:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#20010;&#35859;&#35789;&#20989;&#25968;&#37324;&#34987;&#35843;&#29992;&#12290; fint &#30340;&#21517;&#23383;&#21462;&#24847; &#8220;function intersection&#8221;, &#20511;&#21161;&#23427;,&#21487;&#20197;&#25226;&#20195;&#30721;&#20889;&#25104;&#36825;&#26679; :</span>
<span class="linenr">29:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">(find-if (fint #&#8217;signed #&#8217;sealed #&#8217;delivered) docs)</span>
<span class="linenr">30:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">fint</span> (fn <span style="color: #228b22;">&amp;rest</span> fns)
<span class="linenr">31:  </span>  (<span style="color: #a020f0;">if</span> (null fns)
<span class="linenr">32:  </span>      fn
<span class="linenr">33:  </span>      (<span style="color: #a020f0;">let</span> ((chain (apply #&#8217;fint fns)))
<span class="linenr">34:  </span>        #&#8217;(<span style="color: #a020f0;">lambda</span> (x)
<span class="linenr">35:  </span>             (and (funcall fn x) (funcall chain x))))))
<span class="linenr">36:  </span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#19978;&#38754;&#29992;and&#65292;&#36825;&#20010;&#29992;or&#12290;fun - function union set</span>
<span class="linenr">37:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">fun</span> (fn <span style="color: #228b22;">&amp;rest</span> fns)
<span class="linenr">38:  </span>  (<span style="color: #a020f0;">if</span> (null fns)
<span class="linenr">39:  </span>      fn
<span class="linenr">40:  </span>      (<span style="color: #a020f0;">let</span> ((chain (apply #&#8217;fun fns)))
<span class="linenr">41:  </span>        #&#8217;(<span style="color: #a020f0;">lambda</span> (x)
<span class="linenr">42:  </span>             (or (funcall fn x) (funcall chain x))))))
</pre>


</div>

</div>

<div id="outline-container-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> 在cdr上递归</h3>
<div class="outline-text-3" id="text-5-5">

<p>由于递归函数对于 Lisp 程序非常之重要,因此有必要设计一些实用工具来构造它。本节和下一节将会介绍一些函数,它们能构造两种最常用的递归函数。 <b>在 Common Lisp 里使用这些函数会显得有f些不自然。一旦我们接触到宏的内容,就可以了解如何把这个机制包装得更优雅一些。</b> 第 15.2 节和 15.3节将会介绍那些用来生成递归函数的宏。
</p>
<p>
如果同一个模式在程序里频频出现,这就是一个标志,它意味着这个程序应该用更高层次的抽象改写。在 Lisp 程序里,有什么模式比下面这个函数更常见的呢 :
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">our-length</span> (lst)
<span class="linenr">2:  </span>  (<span style="color: #a020f0;">if</span> (null lst)
<span class="linenr">3:  </span>      0
<span class="linenr">4:  </span>      (1+ (our-length (cdr lst)))))
</pre>

<p>
或者比这个函数更眼熟 :
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">our-every</span> (fn lst)
<span class="linenr">2:  </span>  (<span style="color: #a020f0;">if</span> (null lst)
<span class="linenr">3:  </span>      t
<span class="linenr">4:  </span>      (and (funcall fn (car lst))
<span class="linenr">5:  </span>           (our-every fn (cdr lst)))))
</pre>

<p>
我们不应再直接手写这些函数,而该转而设计一个新的函数,由它代劳生成函数的工作。图 5.5 中的函数构造器名叫 lrec (“list recurser”) ,它可以满足那些在列表上对其 cdr 进行递归操作的绝大多数需要。
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">lrec</span> (rec <span style="color: #228b22;">&amp;optional</span> base)
<span class="linenr"> 2:  </span>  (<span style="color: #a020f0;">labels</span> ((self (lst)
<span class="linenr"> 3:  </span>             (<span style="color: #a020f0;">if</span> (null lst)
<span class="linenr"> 4:  </span>                 (<span style="color: #a020f0;">if</span> (functionp base)
<span class="linenr"> 5:  </span>                     (funcall base)
<span class="linenr"> 6:  </span>                     base)
<span class="linenr"> 7:  </span>                 (funcall rec (car lst)
<span class="linenr"> 8:  </span>                          #&#8217;(<span style="color: #a020f0;">lambda</span> ()
<span class="linenr"> 9:  </span>                               (self (cdr lst)))))))
<span class="linenr">10:  </span>    #&#8217;self))
<span class="linenr">11:  </span>
<span class="linenr">12:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">our-length</span>
<span class="linenr">13:  </span>(lrec #&#8217;(<span style="color: #a020f0;">lambda</span> (x f) (1+ (funcall f))) 0)
<span class="linenr">14:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">our-every</span>
<span class="linenr">15:  </span>(lrec #&#8217;(<span style="color: #a020f0;">lambda</span> (x f) (and (oddp x) (funcall f))) t)
<span class="linenr">16:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">copy-list</span>
<span class="linenr">17:  </span>(lrec #&#8217;(<span style="color: #a020f0;">lambda</span> (x f) (cons x (funcall f))))
<span class="linenr">18:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">remove-duplicates</span>
<span class="linenr">19:  </span>(lrec #&#8217;(<span style="color: #a020f0;">lambda</span> (x f) (adjoin x (funcall f))))
<span class="linenr">20:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">find-if , for some function fn</span>
<span class="linenr">21:  </span>(lrec #&#8217;(<span style="color: #a020f0;">lambda</span> (x f) (<span style="color: #a020f0;">if</span> (fn x) x (funcall f))))
<span class="linenr">22:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">some , for some function fn</span>
<span class="linenr">23:  </span>(lrec #&#8217;(<span style="color: #a020f0;">lambda</span> (x f) (or (fn x) (funcall f))))
</pre>

<p>
<b>用 lrec 定义的函数,其效率并不一定会最理想。事实上,用 lrec 和其它本章将要定义的其它递归函数生成器的方法来实现函数的办法,是与尾递归的思想背道而驰的。鉴于这个原因,这些生成器最适合在程序的最初版本里使用,或者用在那些速度不太关键的地方。</b>
</p>
</div>

</div>

<div id="outline-container-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> 在子树上递归</h3>
<div class="outline-text-3" id="text-5-6">

<p>看下面这几个函数
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">our-copy-tree</span> (tree)
<span class="linenr"> 2:  </span>  (<span style="color: #a020f0;">if</span> (atom tree)
<span class="linenr"> 3:  </span>      tree
<span class="linenr"> 4:  </span>      (cons (our-copy-tree (car tree))
<span class="linenr"> 5:  </span>            (<span style="color: #a020f0;">if</span> (cdr tree) (our-copy-tree (cdr tree))))))
<span class="linenr"> 6:  </span>
<span class="linenr"> 7:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">count-leaves</span> (tree)
<span class="linenr"> 8:  </span>  (<span style="color: #a020f0;">if</span> (atom tree)
<span class="linenr"> 9:  </span>      1
<span class="linenr">10:  </span>      (1+ (count-leaves (car tree))
<span class="linenr">11:  </span>          (or (<span style="color: #a020f0;">if</span> (cdr tree) (count-leaves (cdr tree)))
<span class="linenr">12:  </span>              1))))
<span class="linenr">13:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">flatten&#20063;&#21487;&#20197;&#20687;&#19979;&#38754;&#36825;&#26679;&#23450;&#20041;&#65288;&#23613;&#31649;&#25928;&#29575;&#26377;&#28857;&#20302;&#65289;</span>
<span class="linenr">14:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">flatten</span> (tree)
<span class="linenr">15:  </span>  (<span style="color: #a020f0;">if</span> (atom tree)
<span class="linenr">16:  </span>      (mklist tree)
<span class="linenr">17:  </span>      (nconc (flatten (car tree))
<span class="linenr">18:  </span>             (<span style="color: #a020f0;">if</span> (cdr tree) (flatten (cdr tree))))))
<span class="linenr">19:  </span>
<span class="linenr">20:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">rfind-if</span> (fn tree)
<span class="linenr">21:  </span>  (<span style="color: #a020f0;">if</span> (atom tree)
<span class="linenr">22:  </span>      (and (funcall fn tree) tree)
<span class="linenr">23:  </span>      (or (rfind-if fn (car tree))
<span class="linenr">24:  </span>          (<span style="color: #a020f0;">if</span> (cdr tree) (rfind-if fn (cdr tree))))))
</pre>

<p>
copy-tree , count-leaves , flatten 和 rfind-if ,这四个函数的形式竟然如此相似。我们抽象出下面这个函数
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">ttrav</span> (rec <span style="color: #228b22;">&amp;optional</span> (base #&#8217;identity))
<span class="linenr"> 2:  </span>  (<span style="color: #a020f0;">labels</span> ((self (tree)
<span class="linenr"> 3:  </span>             (<span style="color: #a020f0;">if</span> (atom tree)
<span class="linenr"> 4:  </span>                 (<span style="color: #a020f0;">if</span> (functionp base)
<span class="linenr"> 5:  </span>                     (funcall base tree)
<span class="linenr"> 6:  </span>                     base)
<span class="linenr"> 7:  </span>                 (funcall rec (self (car tree))
<span class="linenr"> 8:  </span>                          (<span style="color: #a020f0;">if</span> (cdr tree)
<span class="linenr"> 9:  </span>                              (self (cdr tree)))))))
<span class="linenr">10:  </span>    #&#8217;self))
<span class="linenr">11:  </span>
<span class="linenr">12:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">our-copy-tree</span>
<span class="linenr">13:  </span>(ttrav #&#8217;cons)
<span class="linenr">14:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">count-leaves</span>
<span class="linenr">15:  </span>(ttrav #&#8217;(<span style="color: #a020f0;">lambda</span> (l r) (+ l (or r 1))) 1)
<span class="linenr">16:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">flatten</span>
<span class="linenr">17:  </span>(ttrav #&#8217;nconc #&#8217;mklist)
</pre>

<p>
但rfind-if不太一样，要定义 rfind-if ,需要更通用的树结构递归操作函数的生成器 , 这种函数生成器能让我们控制递归调用发生的时机,以及是否继续递归。用ttrav实现的函数通常会遍历整棵树，我们需要rfind-if一发现它所要找的元素就停止遍历。
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">trec</span> (rec <span style="color: #228b22;">&amp;optional</span> (base #&#8217;identiy))
<span class="linenr"> 2:  </span>  (<span style="color: #a020f0;">labels</span>
<span class="linenr"> 3:  </span>      ((self (tree)
<span class="linenr"> 4:  </span>         (<span style="color: #a020f0;">if</span> (atom tree)
<span class="linenr"> 5:  </span>             (<span style="color: #a020f0;">if</span> (functionp base)
<span class="linenr"> 6:  </span>                 (funcall base tree)
<span class="linenr"> 7:  </span>                 base)
<span class="linenr"> 8:  </span>             (funcall rec tree
<span class="linenr"> 9:  </span>                      #&#8217;(<span style="color: #a020f0;">lambda</span> ()
<span class="linenr">10:  </span>                           (self (car tree)))
<span class="linenr">11:  </span>                      #&#8217;(<span style="color: #a020f0;">lambda</span> ()
<span class="linenr">12:  </span>                           (<span style="color: #a020f0;">if</span> (cdr tree)
<span class="linenr">13:  </span>                               (self (cdr tree))))))))
<span class="linenr">14:  </span>    #&#8217;self))
<span class="linenr">15:  </span>
<span class="linenr">16:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">&#20351;&#29992; trec &#25105;&#20204;&#21487;&#20197;&#36825;&#26679;&#23450;&#20041; flatten :</span>
<span class="linenr">17:  </span>(trec #&#8217;(<span style="color: #a020f0;">lambda</span> (o l r) (nconc (funcall l) (funcall r)))
<span class="linenr">18:  </span><span style="color: #b22222;">; </span><span style="color: #b22222;">&#29616;&#22312;,&#25105;&#20204;&#21516;&#26679;&#21487;&#20197;&#25226; rfind-if &#20889;&#25104;&#36825;&#26679; ( &#19979;&#38754;&#30340;&#20363;&#23376;&#29992;&#20102; oddp ):</span>
<span class="linenr">19:  </span>(trec #&#8217;(<span style="color: #a020f0;">lambda</span> (o l r) (or (funcall l) (funcall r)))
<span class="linenr">20:  </span>      #&#8217;(<span style="color: #a020f0;">lambda</span> (tree) (and (oddp tree) tree)))
</pre>


</div>

</div>

<div id="outline-container-5-7" class="outline-3">
<h3 id="sec-5-7"><span class="section-number-3">5.7</span> 何时构造函数</h3>
<div class="outline-text-3" id="text-5-7">

<p>   很不幸，如果用构造函数，而非#'的lambda表达式来表示函数会在运行时让程序做一些不必要的工作。虽然sharp-quoted 的 λ– 表达式是一个常量,但是对构造函数的调用将会在运行时求值。如果你真的必须在运行时执行这个调用,可能使用构造函数并非上策。不过,至少有的时候我们可以在事前就调用这个构造函数。通过使用 #. ,即 sharp-dot 读取宏,我们可以让函数在读取期 (read-time) 就被构造出来。假设 compose 和它的参数在下面的表达式被读取时已经被定义了,那么我们可以这样写,举例如下:
</p>
<p>
(find-if #.(compose #’oddp #’truncate) lst)
</p>
<p>
这样做的话, reader 就会对 compose 的调用进行求值,求值得到的函数则被作为常量安插在我们的代码之中。由于 oddp 和 truncate 两者都是内置函数,所以在读取时对 compose 进行估值可以被认为是安全可行的,当然,前提是那个时候 compose 自己已经加载了。
</p>
<p>
一般而言,由宏来完成函数复合或者合并,既简单容易,又提高了程序的性能。这一点对函数拥有具有单独名字空间的 Common Lisp 来说尤其如此。在介绍了宏的相关知识后,我们会在第 15 章故地重游,再次回到这一章中曾走到过的大多数山山水水,所不同的是,到那时候你会骑上更纯种的宝马,配上更奢华的鞍具。
</p>
</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 函数作为表达方式</h2>
<div class="outline-text-2" id="text-6">

<p>  如果把闭包来表示我们以往用静态数据结构表示的对象，就往往可能得到更为优雅，效率更好的程序。在sicp中就讲到用函数来作为cons对的表示。
</p>

</div>

<div id="outline-container-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 网络</h3>
<div class="outline-text-3" id="text-6-1">

<p>   闭包有三个有用的特性：它是动态的，拥有局部状态，而且我们可以创建闭包的多个实例。那么带有局部状态的动态对象的多个拷贝能在什么地方一展身手呢?答案是:和网络有关的程序。许多情况下,我们可以把网络中的节点表示成闭包。闭包在拥有其局部状态的同时,它还能引用其它闭包。因而,一个表示网络中节点的闭包是能够知道作为它发送数据目的地的其他几个节点 ( 闭包 ) 的。换句话说,我们有能力把网络结构直接翻译成代码。
</p>
<p>
   下面我们先看一个文字游戏：
</p>


<pre class="example">&gt; (run-node ’people)
Is the person a man?
&gt;&gt; yes
Is he living?
&gt;&gt; no
Was he American?
&gt;&gt; yes
Is he on a coin?
&gt;&gt; yes
Is the coin a penny?
&gt;&gt; yes
LINCOLN
</pre>

<p>
   在这里我们的网络将会是一颗二叉树。先从习惯的办法着手，先定义某种数据结构来表示节点。
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defstruct</span> <span style="color: #228b22;">node</span> contents yes no)
<span class="linenr">2:  </span>(<span style="color: #a020f0;">defvar</span> <span style="color: #a0522d;">*nodes*</span> (make-hash-table))
<span class="linenr">3:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">defnode</span> (name conts <span style="color: #228b22;">&amp;optional</span> yes no)
<span class="linenr">4:  </span>  (setf (gethash name *nodes*)
<span class="linenr">5:  </span>        (make-node <span style="color: #483d8b;">:contents</span> conts
<span class="linenr">6:  </span>                   <span style="color: #483d8b;">:yes</span>      yes
<span class="linenr">7:  </span>                   <span style="color: #483d8b;">:no</span>       no)))
</pre>

<p>
   为了完成上面的游戏：
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(defnode &#8217;people &#8221;Is the person a man?&#8221; &#8217;male &#8217;female)
<span class="linenr">2:  </span>(defnode &#8217;male &#8221;Is he living?&#8221; &#8217;liveman &#8217;deadman)
<span class="linenr">3:  </span>(defnode &#8217;deadman &#8221;Was he American?&#8221; &#8217;us &#8217;them)
<span class="linenr">4:  </span>(defnode &#8217;us &#8221;Is he on a coin?&#8221; &#8217;coin &#8217;cidence)
<span class="linenr">5:  </span>(defnode &#8217;coin &#8221;Is the coin a penny?&#8221; &#8217;penny &#8217;coins)
<span class="linenr">6:  </span>(defnode &#8217;penny &#8217;lincoln)
</pre>

<p>
   最后定义一个能遍历这个网络的函数了：
</p>


<pre class="src src-lisp"><span class="linenr">1:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">run-node</span> (name)
<span class="linenr">2:  </span>  (<span style="color: #a020f0;">let</span> ((n (gethash name *nodes*)))
<span class="linenr">3:  </span>    (<span style="color: #a020f0;">cond</span> ((node-yes n)
<span class="linenr">4:  </span>           (format t &#8221;~A~%&gt;&gt; &#8221; (node-contents n))
<span class="linenr">5:  </span>           (<span style="color: #a020f0;">case</span> (read)
<span class="linenr">6:  </span>             (yes (run-node (node-yes n)))
<span class="linenr">7:  </span>             (t (run-node (node-no n)))))
<span class="linenr">8:  </span>          (t (node-contents n)))))
</pre>


</div>

</div>

<div id="outline-container-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 编译后的网络</h3>
<div class="outline-text-3" id="text-6-2">

<p>   我们把上面的程序改造一下，变成闭包形式
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defvar</span> <span style="color: #a0522d;">*nodes*</span> (make-hash-table))
<span class="linenr"> 2:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">defnode</span> (name conts <span style="color: #228b22;">&amp;optional</span> yes no)
<span class="linenr"> 3:  </span>  (setf (gethash name *nodes*)
<span class="linenr"> 4:  </span>        (<span style="color: #a020f0;">if</span> yes
<span class="linenr"> 5:  </span>            #&#8217;(<span style="color: #a020f0;">lambda</span> ()
<span class="linenr"> 6:  </span>                 (format t &#8221;~A~%&gt;&gt; &#8221; conts)
<span class="linenr"> 7:  </span>                 (<span style="color: #a020f0;">case</span> (read)
<span class="linenr"> 8:  </span>                   (yes (funcall (gethash yes *nodes*)))
<span class="linenr"> 9:  </span>                   (t   (funcall (gethash no *nodes*)))))
<span class="linenr">10:  </span>               #&#8217;(<span style="color: #a020f0;">lambda</span> () conts))))
</pre>

<p>
   现在我们只需要调用funcall下起始的那个节点就行了：
</p>


<pre class="example">(funcall (gethash ’people *nodes*))
Is the person a man
&gt;&gt;
</pre>

<p>
   借助把节点都表示成闭包的方式,我们得以将 twenty questions 网络完全转化成代码 ( 而非数据 ) 。正如我们所看到的,程序代码必须在运行时按照名字来查找节点函数。然而,如果我们确信网络在运行的时候不会重新定义,那就可以更进一步:让节点函数直接调用它们的下一站目标函数,而不必再动用哈希表了。
</p>
<p>
   使用静态引用的编译过程
</p>


<pre class="src src-lisp"><span class="linenr"> 1:  </span>(<span style="color: #a020f0;">defvar</span> <span style="color: #a0522d;">*nodes*</span> nil)
<span class="linenr"> 2:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">defnode</span> (<span style="color: #228b22;">&amp;rest</span> args)
<span class="linenr"> 3:  </span>  (push args *nodes*)
<span class="linenr"> 4:  </span>  args)
<span class="linenr"> 5:  </span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">compile-net</span> (root)
<span class="linenr"> 6:  </span>  (<span style="color: #a020f0;">let</span> ((node (assoc root *nodes*)))
<span class="linenr"> 7:  </span>    (<span style="color: #a020f0;">if</span> (null node)
<span class="linenr"> 8:  </span>        nil
<span class="linenr"> 9:  </span>        (<span style="color: #a020f0;">let</span> ((conts (second node))
<span class="linenr">10:  </span>              (yes (third node))
<span class="linenr">11:  </span>              (no (fourth node)))
<span class="linenr">12:  </span>          (<span style="color: #a020f0;">if</span> yes
<span class="linenr">13:  </span>              (<span style="color: #a020f0;">let</span> ((yes-fn (compile-net yes))
<span class="linenr">14:  </span>                    (no-fn (compile-net no)))
<span class="linenr">15:  </span>                #&#8217;(<span style="color: #a020f0;">lambda</span> ()
<span class="linenr">16:  </span>                     (format t &#8221;~A~%&gt;&gt; &#8221; conts)
<span class="linenr">17:  </span>                     (funcall (<span style="color: #a020f0;">if</span> (eq (read) &#8217;yes)
<span class="linenr">18:  </span>                                  yes-fn
<span class="linenr">19:  </span>                                  no-fn))))
<span class="linenr">20:  </span>              #&#8217;(<span style="color: #a020f0;">lambda</span> () conts))))))
</pre>

<p>
   我们就调用compile-net来一次性地编译整个网络
</p>


<pre class="example">&gt; (setq n (compile-net ’people))
#&lt;Compiled-Function BF3C06&gt;
&gt; (funcall n)
Is the person a man?
&gt;&gt;
</pre>

<p>
   注意到, compile-net 进行的编译有两层含义。按照通常编译的含义,它把网络的抽象表示翻译成了代码。更进一层,如果 compile-net 自身被编译的话,那它就会返回编译后的函数。
</p>
<p>
   在编译好网络之后,由 defnode 构造的列表就没用了。如果切断列表与程序的联系 ( 例如将 <b>nodes</b> 设为 nil ) ,垃圾收集器就会回收它。
</p>
</div>

</div>

<div id="outline-container-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> 展望</h3>
<div class="outline-text-3" id="text-6-3">

<p>   有许多涉及网络的程序都能通过把节点编译成闭包的形式来实现。闭包作为数据对象,和各种数据结构一样能用来表现事物的属性。这样做需要一些和习惯相左的思考方式,但是作为回报的是更为迅速,更为优雅的程序。
</p></div>
</div>
</div>
</div>
</body>
</html>
